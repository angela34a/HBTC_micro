---
title: "The impact of groundwater temperature on the composition of groundwater microbial communities in an urban aquifer" 
author:  "Angela Cukusic"
output:
  html_document:
    toc: true               # Table of contents
    toc_float: true         # Keep the table of contents floating on the page
    code_download: true     # Enable code download button
    code_copy: true         # Enable code copy button
    number_sections: true   # Numbering the sections
    theme: cerulean           # Choose a Bootstrap theme (check available themes)
    highlight: tango        # Syntax highlighting style 
---

```{r setup, include=FALSE}
# For width of code chunks and scroll bar 
options(width=250)

knitr::opts_chunk$set(eval = TRUE, 
                      echo = TRUE, 
                      cache = TRUE,
                      include = TRUE,
                      warning = FALSE,
                      collapse = FALSE,
                      message = FALSE,
                      engine = "R", 
                      # Chunks will always have R code, unless noted
                      error = TRUE)

```

# Load packages

```{r load-libraries}
library(tidyverse)
library(stringr)
library(broom)
library(rstatix)      # tidyverse-compatible statistical testing
library(ggpmisc)      # adding equation on ggplots
library(vegan)
library(patchwork)    # combining plots in a single figure
library(ggpubr)       # cleaner plotting and for stat_corr
library(MASS)
library(ggfortify)
library(ggrepel)

 
# coordianate plotting
library(mapview)     
library(sf)           
library(geosphere)    



# Set the ggplot theme 
theme_set(theme_linedraw())
```

# Load data

The data has been prepared for analysis with four script in the same repository.
The metadata has been cleaned of unnecessary variables, as well as combined together from both the spring and fall sampling campaing.
It has, furthermore, been decontaminated by the decontam package, the contaminants and blanks were then removed from the count table, replicates of the same sampling site were summed up, and, finally, the temperature categorisation has been added as a variable.

The final count table and taxonomy table (no contaminat ASVs and no blank samples) and clean metadata info is here loaded in.

```{r data-load}

# a) final metadata
metadata <- read.csv("C:/Users/Angela Cukusic/Desktop/DS_analysis/data/clean_data/master_data.csv") %>% 
  dplyr::select(-"X.1") %>% dplyr::filter(Type != "SW")

# b) final asv_table
asv_table <-read.csv("C:/Users/Angela Cukusic/Desktop/DS_analysis/data/clean_data/asv_table_final.csv",
                     check.names = FALSE, row.names = 1)
asv_table <- asv_table[, colnames(asv_table) %in% metadata$sample_season]

# c) final taxonomy table
tax_table <- read.csv("C:/Users/Angela Cukusic/Desktop/DS_analysis/data/clean_data/tax_no_cont.csv",  row.names = 1)

# d) additional data on heat islands
spring_data_additional <- read.csv("C:/Users/Angela Cukusic/Desktop/DS_analysis/data/clean_data/spring_data_additional.csv", 
         check.names = FALSE)
spring_data_additional$sample_season <- paste(spring_data_additional$Sample_ID, 
                                              "spring", sep = "_")
spring_data_additional <- spring_data_additional[,-1]
```

The palettes for the temperature categories color scheme (blue to red; cold to warm) and composition (25 colors distinct from one another to differentiate between taxa abundances).

```{r palette-load}
# color palettes
pal3 = c("#253494", "#225ea8", "#1d91c0", "#7fcdbb" , 
         "#fdbb84", "#d7301f", "#7f0000", "gray")

c25 <- c("dodgerblue2", "#E31A1C", "green4" ,  "#6A3D9A",     "skyblue2", 
         "blue1", "gold1", "brown",  "#FB9A99", "steelblue4" ,  "palegreen2" , 
         "#CAB2D6", "#FDBF6F", "khaki2",  "maroon",  "gray70",  "orchid1",  
         "deeppink1",  "darkorange4",  "green1",  "yellow4"  ,    "yellow3",  
         "beige", "darkturquoise", "#FF7F00" )

name_vector <- c( "ref_cat", "<10", "10-12", "12-14", "14-16", 
                      "16-18",  "18-20",  "20<" )

```

# Alpha diversity

## Temperature distribution

```{r alpha-temp}

# Shannon's index 
shannondiv <- vegan::diversity(t(asv_table))
# turning Shannon's index to effective number of species to be more comparable across studies 
ens <- exp(shannondiv)

p1_en <- cbind(as.data.frame(ens), as.factor(metadata$category)) %>% 
  as.data.frame() %>%
  rename("div"= "ens",
         "temp"="as.factor(metadata$category)") %>%
  filter(temp != "NA") %>% 
# plot
  ggplot( aes(x = temp, y = div, fill = temp)) +
  geom_jitter(width = 0.2, size = 3, shape=21, aes(fill = temp) ) +
  geom_boxplot(alpha=0.5, outlier.shape = NA) +
# add custom palette  
  scale_fill_manual(values = pal3) +
# make  the figure more readable  
  theme(legend.position = "none",
        axis.title=element_text(size=14,face="bold"),
        axis.text.y = element_text(size=10,face="bold"),
        axis.text.x = element_text(angle = 90)) +
  labs(x = "Temperature category",
       y = "Shannon diversity index",
       title = "Diversity by temp. categories") +
  scale_x_discrete(limits = name_vector)  


```

Testing if the distribution of alpha diversity per temperature categories is significant and can be added to the figure in a "\*" form.

```{r alpha-test}

# perform ANOVA?
## 1. assumption: Normal distribution: 
## Each population to be compared should be normally distributed 

cbind( as.data.frame(ens), metadata$category) %>%
  rename("cat" = "metadata$category" ) %>% 
  filter(cat != "NA") %>% 
  group_by(cat) %>% 
  do(tidy(shapiro.test(.$ens)))

# would be better to do a non-parametric test
# since >20 is not normally distributed

## 2. assumption: Homogeneity of variance: 
## Variance in the populations compared should be the same/similar. 
cbind( as.data.frame(ens), metadata$category) %>%
  rename("cat" = "metadata$category" ) %>% 
  filter(cat != "NA") %>% 
  levene_test(ens ~ cat) %>% 
  dplyr::select("p") 
# assumption met
# but irrelevant

# do non-parametric anova
cbind( as.data.frame(ens), metadata$category) %>%
  rename("cat" = "metadata$category" ) %>% 
  filter(cat != "NA") %>% 
  kruskal_test(ens ~ cat)
# significant difference between groups

# do post-hoc to see which
cbind( as.data.frame(ens), metadata$category) %>%
  rename("cat" = "metadata$category" ) %>% 
  filter(cat != "NA") %>% 
  dunn_test(ens ~ cat)
# post-hoc does not show difference
# so no adding to the plot

```

To see if there is a linear trend that gets obscured by the grouping:

```{r alpha-lin}

p1_en_li <- cbind(as.data.frame(shannondiv), metadata$Temp) %>% 
  as.data.frame() %>%
  rename("div"= "shannondiv","temp"="metadata$Temp") %>%
  filter(temp != "NA") %>% 
# plot
  ggplot(aes(temp,div)) + 
  geom_point(shape=21, size = 3, fill = "violet", alpha = 0.9, stroke = 0.6) + 
  geom_smooth(method = "lm", se= FALSE, color = "black") + 
  ggpmisc::stat_poly_eq(use_label(c("eq", "adj.R2", "p")), 
                        label.y = "bottom", size = 3) + 
  labs(y = "Shannon diversity index", x ="Temperature", 
       title = "Linear trend in diversity index") +
  theme(legend.position = "none",
        axis.title=element_text(size=14,face="bold"),
        axis.text.y = element_text(size=10,face="bold"),
        axis.text.x = element_text(angle = 90)) 

p1_en + p1_en_li
```

## Spatial distribution

Plot the diversity index on an interactive map to see if there is a geographical pattern to the alpha diversity.

```{r alpha-spatial}

# add mapview to change X and Y to standard crs
new_metadata2 <- metadata %>% 
  cbind(., as.data.frame(ens)) %>% 
  filter(Temp != "NA") %>% 
# add small value to coordinates for one of the campaigns
# so they do not overlap completely on the map  
  mutate(X = ifelse(grepl("fall", sample_season) , X + 45, X)) %>% 
  dplyr::select("ens", "X", "Y") %>% 
  drop_na() %>% 
  mutate( ens_cat = cut(ens, b=6) )  


pal <-  mapviewPalette("mapviewSpectralColors")

sf_data <- st_as_sf(new_metadata2, coords = c("X", "Y"),  crs = 31253)
mapview(sf_data,  map.types = "Stamen.Terrain", col.regions = pal(10),
        zcol= "ens_cat", zoom = 12, color="black", 
        cex = 5, alpha = 0.7 ) 
```

## Aquifer distributuion

We chose all the aquifers that had more than 5 sampling points to see whether there is an impact of aquifer categorisation on the diversity index.

```{r alpha-aquifer}

cbind( metadata, ens ) %>% 
# filter out >5 aquifers
  dplyr::filter(! Geol_beb %in%  c("n.b.", "lokaler Aquifer",
                                   "Wiental", "Zubringer", "OF")) %>% 
# do not differentiate between the different Donauschotter samples 
                mutate(Geol_beb = case_when( 
                            grepl('DS', Geol_beb) ~ "Donauschotter", 
                                              TRUE ~ Geol_beb)) %>% 
  dplyr::select("ens", "Geol_beb", "Temp") %>% 
  na.omit() %>% 
# plot
  ggplot(aes(x=Temp, y=ens)) + 
  geom_point(shape=21, size = 3, fill = "violet", alpha = 0.9, stroke = 0.5) + 
  geom_smooth(method = "lm", se= FALSE, color = "black") +
  facet_wrap(~ Geol_beb, scales = "free_y", ncol = 2) + 
  #stat_poly_line() +
  stat_poly_eq(use_label(c("eq", "adj.R2", "p")), 
               label.y = "bottom",
               size = 3) + 
  labs(x = "Temperature [°C]",
       y = "Sshannon's diversity index") +
  theme(axis.title.x = element_text(hjust = 0), 
        legend.position = "none",
        axis.title=element_text(size=14,face="bold"),
        axis.text.y = element_text(size=10,face="bold"),
        axis.text.x = element_text(angle = 90),
        strip.text = element_text(size = 12))

```

## Modelling

What environmental variables significantly impact alpha diversity:

```{r alpha-model}

df_alpha <- metadata %>%  
  cbind(as.data.frame(ens)) %>% 
  dplyr::select(where(is.numeric)) %>% 
  dplyr::select(-c("NH4", # many NAs
            "X", "Y")) %>% # coordinates
  na.omit() %>% 
  scale(center = T, scale = T) %>% 
  as.data.frame()
 

# remove the highly correlated ones
cor_matrix <- cor(df_alpha)
highly_correlated <- caret::findCorrelation(cor_matrix, cutoff = 0.9)
df_alpha <- df_alpha[, -highly_correlated] 

# run individual regressions for each variable
varlist <- names(df_alpha)[-19]
models <- lapply(varlist, function(x) {
    form <- formula(paste("ens ~", x))
    lm(form, data=df_alpha)
})
# tidy up the results
lapply(models, function(x) tidy(x)) %>% bind_rows() -> ind_models
ind_models %>% filter(term != "(Intercept)") %>% filter(p.value<0.05)
# none are sign

```

No variables have a significant individual effect.
Let's see if there is a better fit of multiple refression:

```{r alpha-model-combined}


fullModel = lm(ens ~ ., data=df_alpha) # model with all  variables

# remove high vif variables
car::vif(fullModel)  %>% as.data.frame() %>% 
  dplyr::rename("vif"=".") %>% 
  filter(vif<10)  %>% 
  rownames_to_column("envs") %>% 
  dplyr::select("envs")  -> colnames

df_alpha2 <- df_alpha %>% dplyr::select("ens", 
                                       which(colnames(df_alpha) %in% colnames$envs ))

fullModel = lm(ens ~ .  , data = df_alpha2) # model with all  variables


#choose
step.model<- MASS::stepAIC(fullModel, # start with a model containing no variables
                    direction = 'both', # run forward selection
                    trace = 0) # dont show step-by-step process of model selection

#summary(step.model) # none
RsquareAdj(step.model) # <2%

```

# Composition

## Bar plot

For the majority of samples, the most prevailing class was Nanoarchaeia, from the Archaea domain (37.9% ± 15.4% across all categories).
The most abundant class from the Bacteria domain was Omnitrophia (8.10% ± 4.55%), and the fourth most abundant class overall also belonged to the Archaea domain - Nitrososphaeria (5.08% ± 4.67%).
From the phylum Proteobacteria, the most abundant class was Gammaproteobacteria (7.96% ± 6.22%), followed by Alphaproteobacteria (2.73% ± 3.14%).

```{r comp-bar}

#detach(package:plyr, unload = TRUE)

asv_table %>% 
  mutate_if(is.integer, as.numeric) %>% 
  mutate(class = tax_table$Class) %>%
  pivot_longer(cols = -class, values_to = "abundance", names_to = "sample") %>%
  left_join(.,metadata, by = c("sample" = "sample_season")) %>%  
  dplyr::select ("abundance", "class", "category") %>%
# to remove those with no category
  dplyr::filter(category != "NA") %>% 
# to make NA classes Unclassified   
  replace_na(list(class ='Unclassified' )) %>%
  mutate(category = as.factor(category),
         class = as.factor(class)) %>%  
# to find relative abundance within each category  
  dplyr::group_by(category) %>%
  mutate (rel_abund = abundance / sum(abundance)) %>%
  ungroup() %>%
# to sum up all the counts of one class from all the samples  
  dplyr::group_by(category, class) %>%
  summarise(rel_abund = sum(rel_abund)) %>%
  ungroup() %>%
# those very rare categorize as Diverse others 
  dplyr::group_by(category, class) %>%
  mutate(class = case_when(rel_abund< 0.015~ "Diverse others", 
                           TRUE ~ class)) %>%
  ungroup() %>%
# final regrouping after categorizing for Diverse others  
  dplyr::group_by(category, class) %>%
  summarise(rel_abund = sum(rel_abund)) %>%
  ungroup() %>%

# plot
  ggplot(aes(x = category, y = rel_abund, fill = class)) + 
  geom_bar(stat = "identity", color = "black") +
  scale_fill_manual(values=c25) +
  theme(panel.grid = element_blank(), legend.position="right",
        legend.text = element_text(size = 6),      # Adjust the text size
        legend.title = element_text(size = 6),
        legend.key.size = unit(0.4, "cm"),
        axis.title=element_text(size=14,face="bold"),
        axis.text.y = element_text(size=10,face="bold"),
        axis.text.x = element_text(angle = 90, face = "bold")) + 
  labs(x = "Temperature categories",
       y = "Relative abundance", 
       fill = "Class") +
  guides(fill=guide_legend(ncol = 1)) +
  scale_x_discrete(limits = name_vector) 

```

## Bubble plot

The same analysis,but with an alternative visualisation can be done by a bubble plot, where each phylogenetic group is more easily comparable across the categories.

```{r comp-bubble}

asv_table %>% 
  mutate_if(is.integer, as.numeric) %>% 
  mutate(class = tax_table$Class) %>%
  pivot_longer(cols = -class, values_to = "abundance", names_to = "sample") %>%
  left_join(.,metadata, by = c("sample" = "sample_season")) %>%  
  dplyr::select ("abundance", "class", "category") %>%
# to remove those with no category
  dplyr::filter(category != "NA") %>% 
# to make NA classes Unclassified   
  replace_na(list(class ='Unclassified' )) %>%
  mutate(category = as.factor(category),
         class = as.factor(class)) %>%  
# to find relative abundance within each category  
  dplyr::group_by(category) %>%
  mutate (rel_abund = abundance / sum(abundance)) %>%
  ungroup() %>%
# to sum up all the counts of one class from all the samples  
  dplyr::group_by(category, class) %>%
  summarise(rel_abund = sum(rel_abund)) %>%
  ungroup() %>%
# those very rare categorize as Diverse others 
  dplyr::group_by(category, class) %>%
  mutate(class = case_when(rel_abund< 0.015~ "Diverse others", 
                           TRUE ~ class)) %>%
  ungroup() %>%
# final regrouping after categorizing for Diverse others  
  dplyr::group_by(category, class) %>%
  summarise(rel_abund = sum(rel_abund)) %>%
  ungroup() -> data
  
# plot  
data %>% 
  ggplot(aes(x = as.factor(category), y = as.factor(class) )) + 
  geom_point(aes(size = rel_abund, fill=class ), 
             alpha = 0.8, shape = 21, stroke = 0.5) + 
  scale_size_continuous(limits = c(0.001, 0.4), range = c(1,7)) + 
  labs( x= "", y = "", size = "Relative Abundance", fill = "")  + 
  theme(legend.key=element_blank(), 
        axis.text.x = element_text(colour = "black", size = 7, face = "bold", 
                                   angle = 90, vjust = 0.3, hjust = 1),
        axis.text.y = element_text(colour = "black", face = "bold", size = 11), 
        legend.text = element_text(size = 7, face ="bold", colour ="black"), 
        legend.title = element_text(size = 7, face = "bold"), 
        legend.position = "right") +  
  scale_fill_manual(values = c25, guide = "none") +   
  scale_y_discrete(limits = rev(levels(data$class))) +
  scale_x_discrete(limits = name_vector) 

```

Fix this - the code is not valid.

```{r mean-sd}

# i usually do it with phyloseq, try to do it manually
#ps_for_sd <- tax_glom(ps_all, "Class") %>% 
#  transform_sample_counts(., function(x) x/sum(x))

#tb <- psmelt(ps_for_sd) %>%  as_tibble

# manually:
asv_table %>% 
  mutate_if(is.integer, as.numeric) %>% 
  mutate(class = tax_table$Class) %>%
  pivot_longer(cols = -class, values_to = "abundance", names_to = "sample") %>%
# to make NA classes Unclassified   
  replace_na(list(class ='Unclassified' )) %>%
  mutate(class = as.factor(class)) %>% 
# to get relative values
  dplyr::group_by(class) %>%
  mutate (rel_abund = abundance / sum(abundance)) %>%
  ungroup() %>% 
  group_by(class) %>%
  dplyr::summarize( Mean = mean(rel_abund), SD = sd(rel_abund) ) %>%
  ungroup() %>% 
  mutate( Mean_per = .$Mean *100, sd_per = .$SD *100 )  %>% 
  dplyr::filter( Mean_per > 1 ) %>% 
  left_join(., 
            distinct( tax_table[, c("Kingdom", "Phylum", "Class")], Class , 
                      .keep_all = TRUE ) ,
            by=c("class" = "Class") ) 

# not great
tb0 <- tb %>%
  group_by(Class) %>%
  dplyr::summarize( Mean = mean(Abundance), SD = sd(Abundance) ) %>%
  ungroup() %>% 
  mutate( Mean_per = .$Mean *100, sd_per = .$SD *100 )  %>% 
  dplyr::filter( Mean_per > 1 ) %>% 
  left_join(., 
            distinct( new_taxonomy[, c("Kingdom", "Phylum", "Class")], Class , 
                      .keep_all = TRUE ) ,
            by="Class") 

head(tb0[order(tb0$Mean_per), c("Class", "Mean_per", "sd_per", "Phylum")])
head(tb0[, c("Class", "Kingdom", "Phylum")] )

```

## Mathano-gens/trophs

Considering the high methane concentrations in Vienna, we tried connecting the concentrations to the taxa which are connected to the methane processes.

```{r comp-diff}

# 1. clean taxonomy
# subset the "Methylo-" and "Methano-" taxa at the order level
tax_table %>% rownames_to_column("asv") %>%   
# filter the methane taxa
dplyr::filter(grepl('Meth', Order)) %>% 
dplyr::select("asv", "Order")  -> tax_meth


# 2. clean asv_table
# choose only the asvs from the selected orders
asv_table[which(rownames(asv_table) %in% tax_meth$asv ),] %>% 

# only spring has CH4 measures, select spring samples
  rownames_to_column("asv") %>% 
  pivot_longer(cols = -asv, names_to = "samples", values_to = "abundances") %>%
  
# filter only the spring samples
  dplyr::filter(grepl('spring', samples)) %>%   
  
# connect to the order information  
  left_join(., tax_meth, by = "asv") %>% 
  dplyr::select("samples", "Order", "abundances") %>% 
  group_by(samples, Order) %>% 

# sum up the abundance within each order (diff sp/taxa)  
  summarise(abund = sum(abundances)) %>% 
  ungroup() %>% 
  
# remove the samples where abundance is 0
  dplyr::filter(abund != "0") %>% 
  
# connect the asv data to the metadata (methane level)
  left_join(., spring_data_additional[,c("sample_season", "CH4")], 
            by = c("samples" = "sample_season") ) %>% 
  
# remove the samples that do not have methane measures  
 dplyr::filter(CH4 != "NA") %>%
  
# plot 
ggplot(aes(x = CH4 , y = abund)) +
  geom_point(shape=21, size = 3, fill = "violet", alpha = 0.9, stroke = 0.5) + 
  geom_smooth(method = "lm", se= FALSE, color = "black") +
  facet_wrap(~ Order, scales = "free_y") + 
  stat_poly_eq(use_label(c( "adj.R2", "p")), 
               label.y = "top",
               size = 3)

  

# now remove tax_meth since we no longer need it
rm(tax_meth)
```

Although this line seemed promising, the dataset did not have many samples which were outside of the lines of eliminating cross-section (unknown CH4 levels, unclassified order, and/or 0 abundance in the sample).
Taking that into account we can look closer into "Methylococcales", "Methylomirabilales" and "Methanosarciniales".
However, even these three do not provide a robust correlation.

```{r}
# the same filtering as above
asv_table[which(rownames(asv_table) %in% tax_meth$asv ),] %>% 
  rownames_to_column("asv") %>% 
  pivot_longer(cols = -asv, names_to = "samples", values_to = "abundances") %>%
  dplyr::filter(grepl('spring', samples)) %>%   
  left_join(., tax_meth, by = "asv") %>% 
  dplyr::select("samples", "Order", "abundances") %>% 
  group_by(samples, Order) %>% 
  summarise(abund = sum(abundances)) %>% 
  ungroup() %>% 
  dplyr::filter(abund != "0") %>% 
  
# but connect it to the sd_CH4, not CH4 in hopes of clearer trends   
  left_join(., spring_data_additional[,c("sample_season", "Mean_CH4")], 
            by = c("samples" = "sample_season") ) %>% 
  dplyr::filter(Mean_CH4 != "NA") %>%
  
# filter the selected orders   
  dplyr::filter(Order %in% c( "Methylococcales", 
                              "Methylomirabilales", 
                              "Methanosarciniales")) %>% 
  
# plot 
ggplot(aes(x = Mean_CH4 , y = abund)) +
  geom_point(shape=21, size = 3, fill = "violet", alpha = 0.9, stroke = 0.5) + 
  geom_smooth(method = "lm", se= FALSE, color = "black") +
  facet_wrap(~ Order, scales = "free_y") + 
  stat_poly_eq(use_label(c( "adj.R2", "p")), 
               label.y = "top",
               size = 3)

```

# Temperature-related abundance trends

## Linear

We do it again at the phylogenetic level of order.

```{r}

# 1. clean taxonomy
# subset the "Methylo-" and "Methano-" taxa at the order level
tax_table %>% rownames_to_column("asv") %>%   
dplyr::select("asv", "Order") %>% 
# rename the unclassified taxa
replace_na(list(Order ='Unclassified' )) -> tax_order


# 2. manipulate data
asv_table %>% 
  rownames_to_column("asv") %>% 
  pivot_longer(cols = -asv, names_to = "samples", values_to = "abundances") %>%
  
# connect to the order information  
  left_join(., tax_order, by = "asv") %>% 
  dplyr::select("samples", "Order", "abundances") %>% 
  group_by(samples, Order) %>% 

# sum up the abundance within each order (diff sp/taxa)  
  summarise(abund = sum(abundances)) %>% 
  ungroup() %>% 
  
# remove the samples where abundance is 0
  dplyr::filter(abund != "0") %>% 
  
# connect the asv data to the metadata (temperature)
  left_join(., metadata[,c("sample_season", "Temp")], 
            by = c("samples" = "sample_season") ) %>% 
  
# remove the samples that do not have methane measures  
 dplyr::filter(Temp != "NA") %>% 

# filter only the orders which are present in 40+ samples  
  group_by(Order) %>% 
  mutate(n = n()) %>% 
  ungroup() %>% 
  dplyr::filter(n>40)  -> data_for_temp
# this is now 157 orders  


# look at correlations btw order abundances and temperature   
data_for_temp %>% 
 group_by(Order) %>% 
 cor_test(Temp, abund, method = "spearman") %>% 
 ungroup() %>% 
# choose only significant
 dplyr::filter(p<0.05) %>% 
# remove unclassified  
 dplyr::filter(Order != "Unclassified") %>% 
 dplyr::select("Order")  -> corr_orders
    

data_for_temp [which(data_for_temp$Order %in% corr_orders$Order),
               c("Order", "abund",  "Temp")] %>% 
# plot 
ggplot(aes(x = Temp , y = abund)) +
  geom_point(shape=21, size = 3, fill = "violet", alpha = 0.9, stroke = 0.5) + 
  geom_smooth(method = "lm", se= FALSE, color = "black") +
  facet_wrap(~ Order, scales = "free_y") + 
  stat_poly_eq(use_label(c( "adj.R2", "p")), 
               label.y = "top", small.r = TRUE,
               size = 3)


```

Although there are certain significant correlations of order abundance and temperature, the results get less clear when the regression formula is used.
This could be a result of non-parametric methods, like correlation, being generally less affected by outliers.
The only order I would be comfortable claiming shows dependence would be the "Candidatus Roizmanbacteria".

## By category

We start with the 157 orders (orders found in 40+ sasmples), and their abundances and temperature measures.
Instead of using the otherwise present temperature categorisation with 2°C steps, new categorization was done with 0-13-16-16+ temperatures, since \~50% of data points is within the 13-16 range.
This way the cold and warm extreme is on either side of the 13-16 spectrum.

```{r}
data_for_temp %>% dplyr::select(!c("n", "samples")) %>% 
  mutate(temp_cat = case_when(Temp <13 ~ "cold",
                              Temp >15 ~ "hot", 
                              Temp >= 13 & Temp <= 15 ~ "mid")) -> data_for_group


# look at anova btw order abundances and temperature groups 
 data_for_group %>% 
 group_by(Order) %>% 
 anova_test(abund ~ temp_cat) %>% 
 ungroup() %>% 
 as.data.frame() %>%    
# choose only significant
 dplyr::filter(p<0.05) %>% 
 dplyr::select("Order")  -> corr_orders_group
 
 
data_for_group [which(data_for_group$Order %in% corr_orders_group$Order),
               c("Order", "abund",  "temp_cat")] %>% 
# plot 
ggplot(aes(x = temp_cat , y = abund)) +
  geom_jitter(width = 0.2, size = 3, shape=21, fill = "violet") +
  geom_boxplot(fill = "violet", alpha=0.5, outlier.shape = NA) + 
  facet_wrap(~ Order, scales = "free_y") +
  scale_x_discrete(limits = c("cold", "mid", "hot"))



```

# Beta diversity

## Temperature distribution

```{r nmds-temp}
# tax clean
tax_table %>% rownames_to_column("asv") -> tax_tab

# aggregate to genus level
asv_table %>% 
  rownames_to_column("asv") %>% 
  pivot_longer(cols = -asv, names_to = "samples", values_to = "abundances") %>% 
  left_join(., tax_tab, by = "asv") %>% 
  dplyr::select("samples", "Genus", "abundances") %>% 
  group_by(samples,  Genus) %>% 
  summarise(sum(abundances)) %>% 
  ungroup() %>% 
  replace_na(list(Genus ='Unclassified' )) %>%
  pivot_wider(names_from = "samples", values_from = "sum(abundances)") %>% 
  column_to_rownames("Genus") -> asv_aggregated



# do an ordination
sp.dist <-  vegdist(decostand( t(asv_aggregated),  method = "hellinger") )
# or without the transformation
# sp.dist <-  vegdist(t(asv_aggregated))
nmds <- metaMDS(sp.dist, k = 2, autotransform = FALSE)

```

```{r nmds-plot}

# plot it 
nmds_plot <- as.data.frame(nmds$points) %>% 
  cbind(., as.factor(metadata$category)) %>% 
  dplyr::rename("cat" = "as.factor(metadata$category)") %>%
  filter(cat !=  "NA") %>% 
  ggplot(aes(x=MDS1,y=MDS2) ) +
  geom_point(aes( fill= cat), shape = 21, 
             size = 4, alpha = 0.6, stroke = 0.5) +  
  scale_color_manual(values=pal3) +
  scale_fill_manual(values=pal3) +
  annotate(geom="text",x=0.8, y=0.7, label="stress =", color="black") +   
  annotate(geom="text", x=1.1, y=0.7, label=round(nmds$stress,4), color="black") +
  stat_ellipse(aes(colour = cat), linewidth = 0.4) + 
  theme(legend.background = element_blank(),
        legend.box.background = element_rect(colour = "gray")) +
  labs(fill = "Temperature \ncategory") +
  guides(color = "none") +
  geom_vline(xintercept = c(0), color = "grey70", linetype = 2) +
  geom_hline(yintercept = c(0), color = "grey70", linetype = 2) 

nmds_plot
  
```

test ordination

```{r nmds-test}

# 1. test dispersion as an assumption (variance test for multivariate statitics)
disp <- betadisper( sp.dist, metadata$category ) 

#p>0.05 is what we need - homogenous variances
anova(disp) #no sign. differences in dispersion
# if there was sign, i would check with this which one are they
# TukeyHSD(disp) 



# 2. now test actual ordination
# test differences in group centroid with adonis (anova version for multivariate statistics)
permanova <- adonis2(sp.dist ~ metadata$category, na.action = na.omit,
                    method = "bray" , permutations = 999)
permanova # not sign.



# if it was significant i would test which groups are significantly different
#pair_res <- pairwiseAdonis::pairwise.adonis2(t(asv_aggregated) ~ category, data = new_metadata)


```

## Spatial distribution

```{r beta-spatial}
# data with only the coordinates known
data_coo <- metadata %>% 
      dplyr::select("sample_season", "X","Y") %>% 
      na.omit() 

gg <- data_coo %>% 
      st_as_sf(., coords = c("X", "Y"), crs = 31253) %>% 
      st_set_crs(31253) %>% 
      st_transform(4326) %>% 
      st_coordinates() %>%
      as.data.frame() %>%
      distm(., fun = distHaversine) %>%
      as.dist(.) %>% as.vector()

aa <- asv_table[, colnames(asv_table) %in% data_coo$sample_season] %>%  
      t() %>% 
      vegdist(., method = "bray") %>%
      as.vector()


matr <- data.frame(gg, aa)

ggplot(matr, aes(y = gg, x = aa)) + 
  geom_point(size = 3, alpha = 0.9, color="black", 
             shape = 21, fill= "violet",size = 5 ) +
  geom_smooth(method = "lm", colour = "black", alpha = 0.2) +
# add correlation info  
  ggpubr::stat_cor(method = "spearman",  
                   label.y.npc="top", 
                   label.x.npc = "left",
                   color="black", size=4) +
# edit visualization  
  labs(x = "Community dissimilarity", 
       y = "Physical Separation (km)") + 
  theme( axis.text.x = element_text(face = "bold",
                                    colour = "black", size = 12), 
         axis.text.y = element_text(face = "bold", 
                                    size = 11, colour = "black"), 
         axis.title = element_text(face = "bold", 
                                  size = 14, colour = "black")) +
# to turn y scale to kms
  scale_y_continuous(breaks = seq(0, 30000, by = 5000),
                     labels = function(x) x / 1000) 



```

## Aquifer distribution

```{r beta-aquifer}

cbind(metadata, as.data.frame(nmds$points) ) %>% 
dplyr::filter(! Geol_beb %in%  c("n.b.", "lokaler Aquifer",
                                   "Wiental", "Zubringer", "OF")) %>% 
dplyr::select("Geol_beb") %>% 
  na.omit() -> data_aq


# first test assumption: equal dispersion
disp_aq <- betadisper( 
  vegdist(t(  asv_aggregated[,which(colnames(asv_aggregated) %in% rownames(data_aq))] ),
          method = "bray"), 
          data_aq$Geol_beb ) 

#p>0.05 is what we need - homogenous variances
anova(disp_aq) #no sign. differences in dispersion
#TukeyHSD(disp) # if there was sign, i would check with this which one are they


# now test actual ordination
permanova_aq <- adonis2(t( asv_aggregated[,which(colnames(asv_aggregated) %in% rownames(data_aq))] ) ~ 
                        data_aq$Geol_beb, 
                         method = "bray" , 
                        permutations = 999)
permanova # not sign


```

# Environmental data

```{r env-data}
# as done before:
df_alpha <- metadata %>%  
  column_to_rownames("sample_season") %>% 
  dplyr::select(where(is.numeric)) %>% 
  dplyr::select(-c("NH4", # many NAs
            "X", "Y",     # coordinates
            "Extraction_depth", "Watercolumn", "GW_Table")) %>% 
  na.omit() %>% 
  scale(center = T, scale = T) %>% 
  as.data.frame()
cor_matrix <- cor(df_alpha)
highly_correlated <- caret::findCorrelation(cor_matrix, cutoff = 0.9) 
# none
# df_alpha <- df_alpha[, - highly_correlated] 


# lets see if any env vars can be packed neatly in PCs
pca_env <- prcomp(df_alpha, scale = FALSE)
biplot(pca_env)

```

```{r pca-plot}

ggplot2::autoplot(pca_env, 
         
           data = 
           (
           df_alpha %>% 
           rownames_to_column("sample_season") %>% 
           left_join(., metadata[,c("category", "sample_season")], 
                     by = "sample_season") 
           ), 
           
         colour = 'category',
         size=5, 
         alpha = 0.2,
         loadings = TRUE, 
         loadings.colour = "black", 
         loadings.label = TRUE, 
         loadings.label.size = 4.3, 
         loadings.label.colour = "black",
         loadings.label.repel = TRUE) +
  
  geom_vline(xintercept = c(0), color = "grey70", linetype = 2) +
  geom_hline(yintercept = c(0), color = "grey70", linetype = 2) +
  scale_color_manual(values = pal3)+
  theme(legend.background = element_blank(),
        legend.box.background = element_rect(colour = "gray"))  -> pca_plot


pca_plot
```

The first three principal components explain 57% of the environmental variance in data.
We can see that neither this simplification yields as clear results as sometimes obtained.
It is not surprising that the communties nmds gives unclear patterns, as well.

```{r pca-importance}
summary(pca_env)$importance %>% 
  as.data.frame() %>% 
  dplyr::select("PC1", "PC2", "PC3", "PC4")
```

Let us see which variables vary together (group together in which component):

```{r pca-loadings}
# Extract the loadings from the PCA result and convert to tidy format 
loadings_df <-   tidy(pca_env, matrix = "rotation")


# PC1
# Create the ggplot2 object for plotting the loadings
loadings_df %>% filter(PC == "1") %>% 
  #x=reorder(class,-amount,sum)
ggplot( aes(x = reorder(column, -value), y = value, group = factor(column))) +
  geom_bar(stat = "identity", position = "dodge", 
           fill= "gray90", color = "gray20") +
  geom_text(aes(label = column), position = position_dodge(width = 0.9), 
            #vjust = "inward",  
            angle = 90 , hjust = "inward") +
  labs(x = "Variables of PC1", y = "Loadings") +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
        legend.position = "none")  -> plot_pca1

# PC2 
loadings_df %>% filter(PC == "2") %>% 
  #x=reorder(class,-amount,sum)
ggplot( aes(x = reorder(column, -value), y = value, group = factor(column))) +
  geom_bar(stat = "identity", position = "dodge", 
           fill= "gray90", color = "gray20") +
  geom_text(aes(label = column), position = position_dodge(width = 0.9), 
            #vjust = "inward",  
            angle = 90 , hjust = "inward") +
  labs(x = "Variables of PC2", y = "Loadings") +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
        legend.position = "none") -> plot_pca2

# PC3
loadings_df %>% filter(PC == "3") %>% 
  #x=reorder(class,-amount,sum)
ggplot( aes(x = reorder(column, -value), y = value, group = factor(column))) +
  geom_bar(stat = "identity", position = "dodge", 
           fill= "gray90", color = "gray20") +
  geom_text(aes(label = column), position = position_dodge(width = 0.9), 
            #vjust = "inward",  
            angle = 90 , hjust = "inward") +
  labs(x = "Variables of PC3", y = "Loadings") +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
        legend.position = "none") -> plot_pca3

plot_pca1 + plot_pca2 + plot_pca3
```

```{r nmds-pca-plot}
nmds_plot2 <-  as.data.frame(nmds$points) %>% 
  cbind(., as.factor(metadata$category)) %>% 
  dplyr::rename("cat" = "as.factor(metadata$category)") %>%
  filter(cat !=  "NA") %>% 
  ggplot(aes(x=MDS1,y=MDS2) ) +
  geom_point(aes( color = cat),
             size = 5, alpha = 0.2) +  
  scale_color_manual(values=pal3) +
  stat_ellipse(aes(colour = cat), linewidth = 0.4) + 
  theme(legend.position = "none") +
  geom_vline(xintercept = c(0), color = "grey70", linetype = 2) +
  geom_hline(yintercept = c(0), color = "grey70", linetype = 2) 

pca_plot2 <- pca_plot + theme(legend.position = "none") + 
  stat_ellipse(aes(colour = category), linewidth = 0.4) 
nmds_plot2 + pca_plot2
```

Conclusion: there is no distinct clustering by temperature in terms of microbial communities, but there is two different clusters in terms of environmental conditions: \>10 C samples and 18+ samples are separated along the first PCA axis, which was mostly influenced by pH, and various ions/conductivity.
The pH variation is much more pronounced in the cold samples, than warm ones.

While reference samples show low variation in environmental variables and high difference in communities, the opposite is true for extremely cold samples, which are mostly uniform in all variables except for pH and are quite simmilar community-wise.

It is possible that the stress of pH varibility (since pH is known to be a determining factor in composition) selects for resilient organisms, while on the other hand the reference samples allow a more even environment.

## Constrained ordination

CAP ordination as an distance-based alternative to the RDA (which uses bray, as opposed to RDA's euclidean).
Hellinger transformation (square root of relative abundances) is used to account for compositionality of data.

```{r constraints}
# env clean
# df_alpha - already scaled and selected the important variables

# aggregate to genus
# asv_aggregated - already done for nmds
 
# asv clean
# because some samples get removed because of NAs 
asv_aggregated [, which  ( colnames(asv_aggregated) %in% rownames(df_alpha)) ] -> sp.dat

# transform hellinger (or clr sometimes)
decostand(sp.dat, method = "hellinger") -> sp.dat
#clr(sp.dat) -> sp.dat

# 1. first model
simpleRDA <- capscale(t(sp.dat) ~  ., data = df_alpha ,
                 distance = "bray",
                 scaling = "sites")
# take only that are vif<10
env_vars_low_vif <- vif.cca(simpleRDA) %>% 
                    as.data.frame() %>% 
                    dplyr::rename("env" = ".") %>% 
                    dplyr::filter(env < 10) 

df_alpha[,which(colnames(df_alpha) %in%  rownames(env_vars_low_vif) )] -> env.dat


# 2. model without them
simpleRDA <- capscale(t(sp.dat) ~  ., 
                      data=  env.dat ,
                 distance = "bray",
                 scaling = "sites")


# test all variables and axes
# canonical axes
anova.model <- anova.cca(simpleRDA, by='axis', step=1000)  
# no axes sign

# the whole model
anova.model2 <- anova.cca(simpleRDA, step=1000) #is sign
RsquareAdj(simpleRDA)$adj.r.squared # and explains <1%


# env parameters
anova.model3 <- anova(simpleRDA, step=1000, by = "term") 
# none sign



```

None of the environmental variables are significant for the composition.

```{r, eval=FALSE, include=FALSE}

# 3. final model
simpleRDA <- capscale(t(sp.dat) ~  Temp +  DOC + K + O2, data=env.dat ,
                 distance = "bray",
                 scaling = "sites")

#summary(simpleRDA) 
# now 1.4%

```

```{r, eval=FALSE, include=FALSE}
# vectors
ccavectors <- as.matrix(scores(simpleRDA, display = "bp", scaling = "sites")*40) %>% 
  t() %>% as.data.frame() %>% 
  rename("K**" = "K",
         "Temp." = "Temp",
         "O2*" = "O2") %>%
  t() %>% as.data.frame()

# site coordinates
site_data <- scores(simpleRDA, display = "sites") %>% 
  as.data.frame() %>% 
  cbind(., new_metadata$category) %>% 
  rename("cat" = "new_metadata$category")

# plotting
plot_cca <- 
  site_data %>% 
  ggplot( aes(x = CAP1, y = CAP2)) +
  geom_point(aes( color= cat), alpha = 0.2, size = 3) +
  geom_point(aes( color= cat), shape = 21, size = 3) +  
  geom_segment(data = ccavectors, aes(x = 0, y = 0, xend = CAP1, yend = CAP2), size = 1.2,
               arrow = arrow(length = unit(0.5, "cm"))) +
   geom_vline(xintercept = c(0), color = "grey70", linetype = 2) +
   geom_hline(yintercept = c(0), color = "grey70", linetype = 2) +
  geom_text(data = ccavectors, aes(x = CAP1*1.5, y = CAP2*1.5, 
                                   label = rownames(ccavectors)),
                                   #nudge_x = 0.3, nudge_y = 0.3
                                   size=6 ) +
  theme_bw() +
  scale_fill_manual(values= pal3) +
  scale_color_manual(values=pal3) +
  labs(x = "CAP1 [1.6%]", y="CAP2 [0.7%]") +
  stat_ellipse(aes(color=cat), size = 1, alpha = 0.5) + 
  #stat_ellipse(aes(fill = cat), geom="polygon", level=0.95, alpha=0.09) +
  labs( color = "Temperature \ncategory", fill = "Temperature category", 
        title = "Bray distances of hellinger transformed samples (n = 191), 180 classes.") +
  
     theme(legend.background = element_blank(),
           legend.box.background = element_rect(colour = "gray")) 

plot_cca


```

# Donauschotter subset

## Data preparation

```{r ds-prep}
# already added the needed data

# I see that there is one duplicated sample, 
# instead of going back to the data cleaning script I will remove it here
spring_data_additional <- spring_data_additional[ !duplicated(spring_data_additional$sample_season) ,]
# the step before added indexed rownames - remove them
rownames(spring_data_additional) <- c()

spring_data_additional %>% 
  column_to_rownames("sample_season") %>% 
  mutate(OF_beb = as.factor(OF_beb),
         Redox_beb = as.factor(Redox_beb),
         wastew_beb = as.factor(wastew_beb),
         hts_GWWP = as.factor(hts_GWWP),
         hts_EWS = as.factor(hts_EWS),
         hts_No_UHI = as.factor(hts_No_UHI),
         hts_UB = as.factor(hts_UB),
         hts_kanal = as.factor(hts_kanal),
         hts_FW = as.factor(hts_FW),
         hts_Altlast = as.factor(hts_Altlast),
         hts_OGFliess = as.factor(hts_OGFliess),
         hts_OGSteh = as.factor(hts_OGSteh),
         hts_Versie = as.factor(hts_Versie),
         hts_UHI = as.factor(hts_UHI),
         hts_count = as.factor(hts_count)) -> spring_data_additional


# add ens
merge(as.data.frame(ens), spring_data_additional, 
      by = "row.names")  -> spring_data_additional

# filter only DS subset
spring_data_additional %>% 
  dplyr::filter(grepl('DS', Geol_beb)) %>% 
  column_to_rownames("Row.names") -> spring_data_additional
```

## Ens in relation to env vars

```{r ds-uhi}
# of_beb
split_labels <- str_wrap(c("no effect",            # for "1"
                           "running water effect", # for "2"
                           "unclear"),             # for "3"
                         width = 8)

p1 <- spring_data_additional %>% 
  dplyr::filter(OF_beb != "NA") %>% 
  ggplot(aes(x=OF_beb, y=ens)) + 
  geom_jitter(width = 0.2, size = 3, shape=21, fill = "violet") +
  geom_boxplot(fill = "violet", alpha=0.5, outlier.shape = NA) +
  labs(x="Surface water impact", 
       y= "Shannons diversity index") +
  scale_x_discrete(labels = split_labels)


# redox  (Redox_beb)
split_labels <- str_wrap(c("o2 > 2", "o2 < 2", 
                           "Mn>0.15 & Fe>0.15", 
                           "s>0.1"), width = 8)

p2 <- spring_data_additional %>% 
  #dplyr::filter(OF_beb != "NA") %>% 
  ggplot(aes(x=Redox_beb, y=ens)) + 
  geom_jitter(width = 0.2, size = 3, shape=21, fill = "violet") +
  geom_boxplot(fill = "violet", alpha=0.5, outlier.shape = NA) +
  labs(x="Redox cascade", 
       y= NULL) +
  scale_x_discrete(labels = split_labels)


# wastewater  (wastew_beb)
split_labels <- str_wrap(c("no effect",            # for "1"
                           "effect present", # for "2"
                           "unclear"), width = 8)

p3 <- spring_data_additional %>% 
  #dplyr::filter(OF_beb != "NA") %>% 
  ggplot(aes(x=wastew_beb, y=ens)) + 
  geom_jitter(width = 0.2, size = 3, shape=21, fill = "violet") +
  geom_boxplot(fill = "violet", alpha=0.5, outlier.shape = NA) +
  labs(x="Wastewater impact", 
       y= NULL) +
  scale_x_discrete(labels = split_labels)

p1 + p2 + p3
```

## Ens in relation to heat islands

```{r}

# surface sealing
p4 <- spring_data_additional %>% 
  dplyr::filter(hts_Versie != "NA") %>% 
  ggplot(aes(x=hts_Versie, y=ens)) + 
  geom_jitter(width = 0.2, size = 3, shape=21, fill = "violet") +
  geom_boxplot(fill = "violet", alpha=0.5, outlier.shape = NA) + 
  labs(x="Surface sealing", 
       y= "Shannons diversity index") +
 scale_x_discrete(labels = c(">25%", "+25%"))


# number of heat sources
p5 <- spring_data_additional %>% 
  dplyr::filter(hts_UHI != "NA") %>% 
  ggplot(aes(x=hts_UHI, y = ens)) + 
  geom_jitter(width = 0.2, size = 3, shape=21, fill = "violet") +
  geom_boxplot(fill = "violet", alpha=0.5, outlier.shape = NA) + 
  labs(x="UHI count", 
       y= NULL) 


p4 + p5
```

## Ordination

```{r}
# add metals
```
