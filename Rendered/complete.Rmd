---
title: "The impact of groundwater temperature on the composition of groundwater microbial communities in an urban aquifer" 
author:  "Angela Cukusic"
output:
  html_document:
    toc: true               # Table of contents
    toc_float: true         # Keep the table of contents floating on the page
    code_download: true     # Enable code download button
    code_copy: true         # Enable code copy button
    number_sections: true   # Numbering the sections
    theme: united           # Choose a Bootstrap theme (check available themes)
    highlight: tango        # Syntax highlighting style 

---

```{r setup, include=FALSE}
# For width of code chunks and scroll bar 
options(width=250)

knitr::opts_chunk$set(eval = TRUE, 
                      echo = TRUE, 
                      cache = TRUE,
                      include = TRUE,
                      warning = FALSE,
                      collapse = FALSE,
                      message = FALSE,
                      engine = "R", # Chunks will always have R code, unless noted
                      error = TRUE)

```


# load packages
```{r load-libraries} 
library(tidyverse)
library(stringr)
library(broom)
library(rstatix)      # tidyverse-compatible statistical testing
library(ggpmisc)      # adding equation on ggplots
library(vegan)
library(patchwork)    # combining plots in a single figure
library(ggpubr)       # cleaner plotting and for stat_corr
library(MASS)
library(ggfortify)
library(ggrepel)

library(interactions)
library(microViz)
library(microbiome)

 
# coordianate plotting
library(mapview)     
library(sf)           
library(geosphere)    


# Set the ggplot theme 
theme_set(theme_linedraw())
```

# load data 

The data has been prepared for analysis with four script in the same repository. 
The metadata has been cleaned of unnecessary variables, as well as combined together from both the spring and fall sampling campaing. 
It has, furthermore, been decontaminated by the decontam package, the contaminants and blanks were then removed from the count table, replicates of the same sampling site were summed up, and, finally, the temperature categorisation has been added as a variable.

The final count table and taxonomy table (no contaminat ASVs and no blank samples) and clean metadata info is here loaded in.

```{r data-load}
# a) final asv_table
asv_table <-read.csv("C:/Users/Angela Cukusic/Desktop/DS_analysis/data/asv_table_final.csv", 
                     check.names = FALSE, row.names = 1)

# b) final taxonomy table
tax_table <- read.csv("C:/Users/Angela Cukusic/Desktop/DS_analysis/data/tax_no_cont.csv",  row.names = 1)

# c) final metadata
metadata <- read.csv("C:/Users/Angela Cukusic/Desktop/DS_analysis/data/master_data.csv") %>% 
  select(-"X.1")
```

The palettes for the temperature categories color scheme (blue to red; cold to warm) and composition (25 colors distinct from one another to differentiate between taxa abundances).

```{r palette-load}
# color palettes
pal3 = c("#253494", "#225ea8", "#1d91c0", "#7fcdbb" , 
         "#fdbb84", "#d7301f", "#7f0000", "gray")

c25 <- c("dodgerblue2", "#E31A1C", "green4" ,  "#6A3D9A",     "skyblue2", 
         "blue1", "gold1", "brown",  "#FB9A99", "steelblue4" ,  "palegreen2" , 
         "#CAB2D6", "#FDBF6F", "khaki2",  "maroon",  "gray70",  "orchid1",  
         "deeppink1",  "darkorange4",  "green1",  "yellow4"  ,    "yellow3",  
         "beige", "darkturquoise", "#FF7F00" )

name_vector <- c( "ref_cat", "<10", "10-12", "12-14", "14-16", 
                      "16-18",  "18-20",  "20<" )

```


# analysis 

## alpha diversity

### temperature distribution

```{r alpha-temp}

# Shannon's index 
shannondiv <- vegan::diversity(t(asv_table))
# turning Shannon's index to effective number of species to be more comparable across studies 
ens <- exp(shannondiv)

p1_en <- cbind(as.data.frame(ens), as.factor(metadata$category)) %>% 
  as.data.frame() %>%
  rename("div"= "ens",
         "temp"="as.factor(metadata$category)") %>%
  filter(temp != "NA") %>% 
# plot
  ggplot( aes(x = temp, y = div, fill = temp)) +
  geom_jitter(width = 0.2, size = 3, shape=21, aes(fill = temp) ) +
  geom_boxplot(alpha=0.5, outlier.shape = NA) +
# add custom palette  
  scale_fill_manual(values = pal3) +
# make  the figure more readable  
  theme(legend.position = "none",
        axis.title=element_text(size=14,face="bold"),
        axis.text.y = element_text(size=10,face="bold"),
        axis.text.x = element_text(angle = 90)) +
  labs(x = "Temperature category",
       y = "Shannon diversity index",
       title = "Diversity by temp. categories") +
  scale_x_discrete(limits = name_vector)  


```


Testing if the distribution of alpha diversity per temperature categories is significant and can be added to the figure in a "*" form.

```{r alpha-test}


# perform ANOVA?
## 1. assumption: Normal distribution: 
## Each population to be compared should be normally distributed 

cbind( as.data.frame(ens), metadata$category) %>%
  rename("cat" = "metadata$category" ) %>% 
  filter(cat != "NA") %>% 
  group_by(cat) %>% 
  do(tidy(shapiro.test(.$ens)))

# would be better to do a non-parametric test
# since >20 is not normally distributed

## 2. assumption: Homogeneity of variance: 
## Variance in the populations compared should be the same/similar. 
cbind( as.data.frame(ens), metadata$category) %>%
  rename("cat" = "metadata$category" ) %>% 
  filter(cat != "NA") %>% 
  levene_test(ens ~ cat) %>% 
  select("p") 
# assumption met
# but irrelevant

# do non-parametric anova
cbind( as.data.frame(ens), metadata$category) %>%
  rename("cat" = "metadata$category" ) %>% 
  filter(cat != "NA") %>% 
  kruskal_test(ens ~ cat)
# significant difference between groups

# do post-hoc to see which
cbind( as.data.frame(ens), metadata$category) %>%
  rename("cat" = "metadata$category" ) %>% 
  filter(cat != "NA") %>% 
  dunn_test(ens ~ cat)
# post-hoc does not show difference
# so no adding to the plot

```



To see if there is a linear trend that gets obscured by the grouping:
```{r alpha-lin}

p1_en_li <- cbind(as.data.frame(shannondiv), metadata$Temp) %>% 
  as.data.frame() %>%
  rename("div"= "shannondiv","temp"="metadata$Temp") %>%
  filter(temp != "NA") %>% 
# plot
  ggplot(aes(temp,div)) + 
  geom_point(shape=21, size = 3, fill = "violet", alpha = 0.9, stroke = 0.6) + 
  geom_smooth(method = "lm", se= FALSE, color = "black") + 
  ggpmisc::stat_poly_eq(use_label(c("eq", "adj.R2", "p")), 
                        label.y = "bottom", size = 3) + 
  labs(y = "Shannon diversity index", x ="Temperature", 
       title = "Linear trend in diversity index") +
  theme(legend.position = "none",
        axis.title=element_text(size=14,face="bold"),
        axis.text.y = element_text(size=10,face="bold"),
        axis.text.x = element_text(angle = 90)) 

p1_en + p1_en_li
```

### spatial distribution
Plot the diversity index on an interactive map to see if there is a geographical pattern to the alpha diversity.

```{r alpha-spatial}

# add mapview to change X and Y to standard crs
new_metadata2 <- metadata %>% 
  cbind(., as.data.frame(ens)) %>% 
  filter(Temp != "NA") %>% 
# add small value to coordinates for one of the campaigns
# so they do not overlap completely on the map  
  mutate(X = ifelse(grepl("fall", sample_season) , X + 45, X)) %>% 
  dplyr::select("ens", "X", "Y") %>% 
  drop_na() %>% 
  mutate( ens_cat = cut(ens, b=6) )  


pal <-  mapviewPalette("mapviewSpectralColors")

sf_data <- st_as_sf(new_metadata2, coords = c("X", "Y"),  crs = 31253)
mapview(sf_data,  map.types = "Stamen.Terrain", col.regions = pal(10),
        zcol= "ens_cat", zoom = 12, color="black", 
        cex = 5, alpha = 0.7 ) 
```


### aquifer distributuion
We chose all the aquifers that had more than 5 sampling points to see whether there is an impact of aquifer categorisation on the diversity index.

```{r alpha-aquifer}

cbind( metadata, ens ) %>% 
# filter out >5 aquifers
  dplyr::filter(! Geol_beb %in%  c("n.b.", "lokaler Aquifer",
                                   "Wiental", "Zubringer", "OF")) %>% 
# do not differentiate between the different Donauschotter samples 
                mutate(Geol_beb = case_when( 
                            grepl('DS', Geol_beb) ~ "Donauschotter", 
                                              TRUE ~ Geol_beb)) %>% 
  select("ens", "Geol_beb", "Temp") %>% 
  na.omit() %>% 
# plot
  ggplot(aes(x=Temp, y=ens)) + 
  geom_point(shape=21, size = 3, fill = "violet", alpha = 0.9, stroke = 0.5) + 
  geom_smooth(method = "lm", se= FALSE, color = "black") +
  facet_wrap(~ Geol_beb, scales = "free_y", ncol = 2) + 
  #stat_poly_line() +
  stat_poly_eq(use_label(c("eq", "adj.R2", "p")), 
               label.y = "bottom",
               size = 3) + 
  labs(x = "Temperature",
       y = "Sshannon's diversity index") +
  theme(axis.title.x = element_text(hjust = 0), 
        legend.position = "none",
        axis.title=element_text(size=14,face="bold"),
        axis.text.y = element_text(size=10,face="bold"),
        axis.text.x = element_text(angle = 90),
        strip.text = element_text(size = 12))

```


### modelling 
What environmental variables significantly impact alpha diversity:
```{r alpha-model}

df_alpha <- metadata %>%  
  cbind(as.data.frame(ens)) %>% 
  dplyr::select(where(is.numeric)) %>% 
  dplyr::select(-c("NH4", # many NAs
            "X", "Y")) %>% # coordinates
  na.omit() %>% 
  scale(center = T, scale = T) %>% 
  as.data.frame()
 

# remove the highly correlated ones
cor_matrix <- cor(df_alpha)
highly_correlated <- caret::findCorrelation(cor_matrix, cutoff = 0.9)
df_alpha <- df_alpha[, -highly_correlated] 

# run individual regressions for each variable
varlist <- names(df_alpha)[-19]
models <- lapply(varlist, function(x) {
    form <- formula(paste("ens ~", x))
    lm(form, data=df_alpha)
})
# tidy up the results
lapply(models, function(x) tidy(x)) %>% bind_rows() -> ind_models
ind_models %>% filter(term != "(Intercept)") %>% filter(p.value<0.05)
# only Ca and Well depth have significant relationships with ens


lm(ens ~ Ca, data = df_alpha) %>%  summary()
# explains <2%
lm(ens ~ Well_depth, data = df_alpha) %>%  summary()
# explains <2%


```

Only variables which have a significant individual effect are Calcium and well depth, however, they do not have a good model fit. Let's see if there is a better fit of multiple refression:

```{r alpha-model-combined}


fullModel = lm(ens ~ ., data=df_alpha) # model with all  variables

# remove high vif variables
vif(fullModel)  %>% as.data.frame() %>% 
  dplyr::rename("vif"=".") %>% 
  filter(vif<10)  %>% 
  rownames_to_column("envs") %>% 
  dplyr::select("envs")  -> colnames

df_alpha2 <- df_alpha %>% dplyr::select("ens", 
                                       which(colnames(df_alpha) %in% colnames$envs ))

fullModel = lm(ens ~ .  , data = df_alpha2) # model with all  variables


#choose
step.model<- MASS::stepAIC(fullModel, # start with a model containing no variables
                    direction = 'both', # run forward selection
                    trace = 0) # dont show step-by-step process of model selection

#summary(step.model) # none
RsquareAdj(step.model) # <1%

```



## composition

### bar plot
```{r comp-bar}

# with microviz
detach(package:plyr, unload = TRUE)

asv_table %>% 
  mutate_if(is.integer, as.numeric) %>% 
  mutate(class = tax_table$Class) %>%
  pivot_longer(cols = -class, values_to = "abundance", names_to = "sample") %>%
  left_join(.,metadata, by = c("sample" = "sample_season")) %>%  
  dplyr::select ("abundance", "class", "category") %>%
# to remove those with no category
  dplyr::filter(category != "NA") %>% 
# to make NA classes Unclassified   
  replace_na(list(class ='Unclassified' )) %>%
  mutate(category = as.factor(category),
         class = as.factor(class)) %>%  
# to find relative abundance within each category  
  dplyr::group_by(category) %>%
  mutate (rel_abund = abundance / sum(abundance)) %>%
  ungroup() %>%
# to sum up all the counts of one class from all the samples  
  dplyr::group_by(category, class) %>%
  summarise(rel_abund = sum(rel_abund)) %>%
  ungroup() %>%
# those very rare categorize as Diverse others 
  dplyr::group_by(category, class) %>%
  mutate(class = case_when(rel_abund< 0.015~ "Diverse others", 
                           TRUE ~ class)) %>%
  ungroup() %>%
# final regrouping after categorizing for Diverse others  
  dplyr::group_by(category, class) %>%
  summarise(rel_abund = sum(rel_abund)) %>%
  ungroup() %>%

# plot
  ggplot(aes(x = category, y = rel_abund, fill = class)) + 
  geom_bar(stat = "identity", color = "black") +
  scale_fill_manual(values=c25) +
  theme(panel.grid = element_blank(), legend.position="right",
        legend.text = element_text(size = 6),      # Adjust the text size
        legend.title = element_text(size = 6),
        legend.key.size = unit(0.4, "cm"),
        axis.title=element_text(size=14,face="bold"),
        axis.text.y = element_text(size=10,face="bold"),
        axis.text.x = element_text(angle = 90, face = "bold")) + 
  labs(x = "Temperature categories",
       y = "Relative abundance", 
       fill = "Class") +
  guides(fill=guide_legend(ncol = 1)) +
  scale_x_discrete(limits = name_vector) 

```

### bubble plot
```{r}

asv_table %>% 
  mutate_if(is.integer, as.numeric) %>% 
  mutate(class = tax_table$Class) %>%
  pivot_longer(cols = -class, values_to = "abundance", names_to = "sample") %>%
  left_join(.,metadata, by = c("sample" = "sample_season")) %>%  
  dplyr::select ("abundance", "class", "category") %>%
# to remove those with no category
  dplyr::filter(category != "NA") %>% 
# to make NA classes Unclassified   
  replace_na(list(class ='Unclassified' )) %>%
  mutate(category = as.factor(category),
         class = as.factor(class)) %>%  
# to find relative abundance within each category  
  dplyr::group_by(category) %>%
  mutate (rel_abund = abundance / sum(abundance)) %>%
  ungroup() %>%
# to sum up all the counts of one class from all the samples  
  dplyr::group_by(category, class) %>%
  summarise(rel_abund = sum(rel_abund)) %>%
  ungroup() %>%
# those very rare categorize as Diverse others 
  dplyr::group_by(category, class) %>%
  mutate(class = case_when(rel_abund< 0.015~ "Diverse others", 
                           TRUE ~ class)) %>%
  ungroup() %>%
# final regrouping after categorizing for Diverse others  
  dplyr::group_by(category, class) %>%
  summarise(rel_abund = sum(rel_abund)) %>%
  ungroup() -> data
  
# plot  
data %>% 
  ggplot(aes(x = as.factor(category), y = as.factor(class) )) + 
  geom_point(aes(size = rel_abund, fill=class ), 
             alpha = 0.8, shape = 21, stroke = 0.5) + 
  scale_size_continuous(limits = c(0.001, 0.4), range = c(1,7)) + 
  labs( x= "", y = "", size = "Relative Abundance", fill = "")  + 
  theme(legend.key=element_blank(), 
        axis.text.x = element_text(colour = "black", size = 12, face = "bold", 
                                   angle = 90, vjust = 0.3, hjust = 1),
        axis.text.y = element_text(colour = "black", face = "bold", size = 11), 
        legend.text = element_text(size = 10, face ="bold", colour ="black"), 
        legend.title = element_text(size = 12, face = "bold"), 
        legend.position = "right") +  
  scale_fill_manual(values = c25, guide = "none") +   
  scale_y_discrete(limits = rev(levels(data$class))) +
  scale_x_discrete(limits = name_vector) 

```


```{r mean-sd}

# mean + sd 
ps_for_sd <- tax_glom(ps_all, "Class") %>% 
  transform_sample_counts(., function(x) x/sum(x))

tb <- psmelt(ps_for_sd) %>%
  as_tibble

asv_table %>% 
  mutate_if(is.integer, as.numeric) %>% 
  mutate(class = tax_table$Class) %>%
  pivot_longer(cols = -class, values_to = "abundance", names_to = "sample") %>%
# to make NA classes Unclassified   
  replace_na(list(class ='Unclassified' )) %>%
  mutate(class = as.factor(class)) %>% 
# to get relative values
  dplyr::group_by(class) %>%
  mutate (rel_abund = abundance / sum(abundance)) %>%
  ungroup() %>% 
  group_by(class) %>%
  dplyr::summarize( Mean = mean(rel_abund), SD = sd(rel_abund) ) %>%
  ungroup() %>% 
  mutate( Mean_per = .$Mean *100, sd_per = .$SD *100 )  %>% 
  dplyr::filter( Mean_per > 1 ) %>% 
  left_join(., 
            distinct( tax_table[, c("Kingdom", "Phylum", "Class")], Class , 
                      .keep_all = TRUE ) ,
            by=c("class" = "Class") ) 



tb0 <- tb %>%
  group_by(Class) %>%
  dplyr::summarize( Mean = mean(Abundance), SD = sd(Abundance) ) %>%
  ungroup() %>% 
  mutate( Mean_per = .$Mean *100, sd_per = .$SD *100 )  %>% 
  dplyr::filter( Mean_per > 1 ) %>% 
  left_join(., 
            distinct( new_taxonomy[, c("Kingdom", "Phylum", "Class")], Class , 
                      .keep_all = TRUE ) ,
            by="Class") 

head(tb0[order(tb0$Mean_per), c("Class", "Mean_per", "sd_per", "Phylum")])
head(tb0[, c("Class", "Kingdom", "Phylum")] )

```



```{r comp-diff}

```



## beta diversity


### temperature distribution

```{r nmds-temp}
# tax clean
tax_table %>% rownames_to_column("asv") -> tax_tab


# aggregate to genus level
asv_table %>% 
  rownames_to_column("asv") %>% 
  pivot_longer(cols = -asv, names_to = "samples", values_to = "abundances") %>% 
  left_join(., tax_tab, by = "asv") %>% 
  dplyr::select("samples", "Genus", "abundances") %>% 
  group_by(samples,  Genus) %>% 
  summarise(sum(abundances)) %>% 
  ungroup() %>% 
  replace_na(list(Genus ='Unclassified' )) %>%
  pivot_wider(names_from = "samples", values_from = "sum(abundances)") %>% 
  column_to_rownames("Genus") -> asv_aggregated



# do an ordination
sp.dist <-  vegdist(decostand( t(asv_aggregated),  method = "hellinger") )
# or without the transformation
# sp.dist <-  vegdist(t(asv_aggregated))
nmds <- metaMDS(sp.dist, k = 2, autotransform = FALSE)

```

```{r nmds-plot}

# plot it 
nmds_plot <- as.data.frame(nmds$points) %>% 
  cbind(., as.factor(metadata$category)) %>% 
  dplyr::rename("cat" = "as.factor(metadata$category)") %>%
  filter(cat !=  "NA") %>% 
  ggplot(aes(x=MDS1,y=MDS2) ) +
  geom_point(aes( fill= cat), shape = 21, 
             size = 4, alpha = 0.6, stroke = 0.5) +  
  scale_color_manual(values=pal3) +
  scale_fill_manual(values=pal3) +
  annotate(geom="text",x=0.8, y=0.7, label="stress =", color="black") +   
  annotate(geom="text", x=1.1, y=0.7, label=round(nmds$stress,4), color="black") +
  stat_ellipse(aes(colour = cat), linewidth = 0.4) + 
  theme(legend.background = element_blank(),
        legend.box.background = element_rect(colour = "gray")) +
  labs(fill = "Temperature \ncategory") +
  guides(color = "none") +
  geom_vline(xintercept = c(0), color = "grey70", linetype = 2) +
   geom_hline(yintercept = c(0), color = "grey70", linetype = 2) 

nmds_plot
  
```


test ordination
```{r nmds-test}

# 1. test dispersion as an assumption (variance test for multivariate statitics)
disp <- betadisper( sp.dist, metadata$category ) 

#p>0.05 is what we need - homogenous variances
anova(disp) #no sign. differences in dispersion
# if there was sign, i would check with this which one are they
# TukeyHSD(disp) 



# 2. now test actual ordination
# test differences in group centroid with adonis (anova version for multivariate statistics)
permanova <- adonis2(sp.dist ~ metadata$category, na.action = na.omit,
                    method = "bray" , permutations = 999)
permanova # not sign.



# if it was significant i would test which groups are significantly different
#pair_res <- pairwiseAdonis::pairwise.adonis2(t(asv_aggregated) ~ category, data = new_metadata)


```


### spatial distribution
```{r beta-spatial}
# data with only the coordinates known
data_coo <- metadata %>% 
      select("sample_season", "X","Y") %>% 
      na.omit() 

gg <- data_coo %>% 
      st_as_sf(., coords = c("X", "Y"), crs = 31253) %>% 
      st_set_crs(31253) %>% 
      st_transform(4326) %>% 
      st_coordinates() %>%
      as.data.frame() %>%
      distm(., fun = distHaversine) %>%
      as.dist(.) %>% as.vector()

aa <- asv_table[, colnames(asv_table) %in% data_coo$sample_season] %>%  
      t() %>% 
      vegdist(., method = "bray") %>%
      as.vector()


matr <- data.frame(gg, aa)

ggplot(matr, aes(y = gg, x = aa)) + 
  geom_point(size = 3, alpha = 0.9, color="black", 
             shape = 21, fill= "violet",size = 5 ) +
  geom_smooth(method = "lm", colour = "black", alpha = 0.2) +
# add correlation info  
  ggpubr::stat_cor(method = "spearman",  
                   label.y.npc="top", 
                   label.x.npc = "left",
                   color="black", size=4) +
# edit visualization  
  labs(x = "Community dissimilarity", 
       y = "Physical Separation (km)") + 
  theme( axis.text.x = element_text(face = "bold",
                                    colour = "black", size = 12), 
         axis.text.y = element_text(face = "bold", 
                                    size = 11, colour = "black"), 
         axis.title = element_text(face = "bold", 
                                  size = 14, colour = "black")) +
# to turn y scale to kms
  scale_y_continuous(breaks = seq(0, 30000, by = 5000),
                     labels = function(x) x / 1000) 



```



### aquifer distribution
```{r beta-aquifer}

cbind(metadata, as.data.frame(nmds$points) ) %>% 
dplyr::filter(! Geol_beb %in%  c("n.b.", "lokaler Aquifer",
                                   "Wiental", "Zubringer", "OF")) %>% 
dplyr::select("Geol_beb") %>% 
  na.omit() -> data_aq


# first test assumption: equal dispersion
disp_aq <- betadisper( 
  vegdist(t(  asv_aggregated[,which(colnames(asv_aggregated) %in% rownames(data_aq))] ),
          method = "bray"), 
          data_aq$Geol_beb ) 

#p>0.05 is what we need - homogenous variances
anova(disp_aq) #no sign. differences in dispersion
#TukeyHSD(disp) # if there was sign, i would check with this which one are they


# now test actual ordination
permanova_aq <- adonis2(t( asv_aggregated[,which(colnames(asv_aggregated) %in% rownames(data_aq))] ) ~ 
                        data_aq$Geol_beb, 
                         method = "bray" , 
                        permutations = 999)
permanova # not sign


```



## environmental data

```{r}
# as done before:
df_alpha <- metadata %>%  
  cbind(as.data.frame(ens)) %>% 
  dplyr::select(where(is.numeric)) %>% 
  dplyr::select(-c("NH4", # many NAs
            "X", "Y",     # coordinates
            "Extraction_depth", "Watercolumn", "GW_Table")) %>% 
  na.omit() %>% 
  scale(center = T, scale = T) %>% 
  as.data.frame()
cor_matrix <- cor(df_alpha)
highly_correlated <- caret::findCorrelation(cor_matrix, cutoff = 0.9)
df_alpha <- df_alpha[, -highly_correlated] 


# lets see if any env vars can be packed neatly in PCs
pca_env <- prcomp(df_alpha, scale = FALSE)
biplot(pca_env)

# sample 10_27H_fall since it is a single outlier 
# in almost every variable, and stresses the ordination
pca_env <- prcomp(df_alpha[rownames(df_alpha) != "10-27H_fall",], scale = FALSE)
```

```{r}

ggplot2::autoplot(pca_env, 
         
           data = 
           (
           df_alpha[rownames(df_alpha) != "10-27H_fall",] %>% 
           rownames_to_column("sample_season") %>% 
           left_join(., metadata[,c("category", "sample_season")], 
                     by = "sample_season") 
           ), 
           
         colour = 'category',
         size=5, 
         alpha = 0.2,
         loadings=TRUE, 
         loadings.colour="black", 
         loadings.label=TRUE, 
         loadings.label.size=5, 
         loadings.label.colour="black" ) +
  
  geom_text_repel(label = loadings_df) +
  geom_vline(xintercept = c(0), color = "grey70", linetype = 2) +
  geom_hline(yintercept = c(0), color = "grey70", linetype = 2) +
  scale_color_manual(values = pal3)+
  theme(legend.background = element_blank(),
        legend.box.background = element_rect(colour = "gray"))  -> pca_plot


pca_plot
```

```{r}
# Extract the loadings from the PCA result and convert to tidy format 
loadings_df <-   tidy(pca_env, matrix = "rotation")


# PC1
# Create the ggplot2 object for plotting the loadings
loadings_df %>% filter(PC == "1") %>% 
  #x=reorder(class,-amount,sum)
ggplot( aes(x = reorder(column, -value), y = value, group = factor(column))) +
  geom_bar(stat = "identity", position = "dodge", 
           fill= "gray90", color = "gray20") +
  geom_text(aes(label = column), position = position_dodge(width = 0.9), 
            #vjust = "inward",  
            angle = 90 , hjust = "inward") +
  labs(x = "Variables of PC1", y = "Loadings") +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
        legend.position = "none")  -> plot_pca1

# PC2 
loadings_df %>% filter(PC == "2") %>% 
  #x=reorder(class,-amount,sum)
ggplot( aes(x = reorder(column, -value), y = value, group = factor(column))) +
  geom_bar(stat = "identity", position = "dodge", 
           fill= "gray90", color = "gray20") +
  geom_text(aes(label = column), position = position_dodge(width = 0.9), 
            #vjust = "inward",  
            angle = 90 , hjust = "inward") +
  labs(x = "Variables of PC2", y = "Loadings") +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
        legend.position = "none") -> plot_pca2

# PC3
loadings_df %>% filter(PC == "3") %>% 
  #x=reorder(class,-amount,sum)
ggplot( aes(x = reorder(column, -value), y = value, group = factor(column))) +
  geom_bar(stat = "identity", position = "dodge", 
           fill= "gray90", color = "gray20") +
  geom_text(aes(label = column), position = position_dodge(width = 0.9), 
            #vjust = "inward",  
            angle = 90 , hjust = "inward") +
  labs(x = "Variables of PC3", y = "Loadings") +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
        legend.position = "none") -> plot_pca3

plot_pca1 + plot_pca2 + plot_pca3
```


```{r}
# env clean

new_metadata %>% dplyr::select(where(is.numeric)) %>% 
                  dplyr::select(!c("Fe", "NO3", "NH3", "DOM_bix", "X", "Y")) %>% 
                  scale() %>% as.data.frame()  -> env.dat



# aggregate to class
sp.dat <- asv_aggregated # already done for nmds


# asv clean
sp.dat [, which  ( colnames(sp.dat) %in% rownames(env.dat)) ] -> sp.dat

# transform hellinger (or clr sometimes)
decostand(sp.dat, method = "hellinger") -> sp.dat
#clr(sp.dat) -> sp.dat


simpleRDA <- capscale(t(sp.dat) ~  ., data=env.dat ,
                 distance = "bray",
                 scaling = "sites")

# summary(simpleRDA)
#9.6% constrained but look at vif

env_vars_low_vif <- vif.cca(simpleRDA) %>% 
                    as.data.frame() %>% 
                    dplyr::rename("env" = ".") %>% 
                    dplyr::filter(env < 10) 

 env.dat[,which(colnames(env.dat) %in%  rownames(env_vars_low_vif) )] -> env.dat


# without them
simpleRDA <- capscale(t(sp.dat) ~  ., 
                      data=  env.dat ,
                 distance = "bray",
                 scaling = "sites")

#summary(simpleRDA) 
# now 5.6%

```

test it
```{r}


# Test of all canonical axes
anova.model <- anova.cca(simpleRDA, by='axis', step=1000)  # cap1 is sign, cap2 not

# test the whole model
anova.model2 <- anova.cca(simpleRDA, step=1000) #is sign
RsquareAdj(simpleRDA)$adj.r.squared # and explains 1.7%


# test env paameters
anova.model3 <- anova(simpleRDA, step=1000, by = "term") #Temp + DOC sign, and K + O2 borderline


# new model
simpleRDA <- capscale(t(sp.dat) ~  Temp +  DOC + K + O2, data=env.dat ,
                 distance = "bray",
                 scaling = "sites")

#summary(simpleRDA) 
# now 1.4%

```

```{r}
# vectors
ccavectors <- as.matrix(scores(simpleRDA, display = "bp", scaling = "sites")*40) %>% 
  t() %>% as.data.frame() %>% 
  rename("K**" = "K",
         "Temp." = "Temp",
         "O2*" = "O2") %>%
  t() %>% as.data.frame()

# site coordinates
site_data <- scores(simpleRDA, display = "sites") %>% 
  as.data.frame() %>% 
  cbind(., new_metadata$category) %>% 
  rename("cat" = "new_metadata$category")

# plotting
plot_cca <- 
  site_data %>% 
  ggplot( aes(x = CAP1, y = CAP2)) +
  geom_point(aes( color= cat), alpha = 0.2, size = 3) +
  geom_point(aes( color= cat), shape = 21, size = 3) +  
  geom_segment(data = ccavectors, aes(x = 0, y = 0, xend = CAP1, yend = CAP2), size = 1.2,
               arrow = arrow(length = unit(0.5, "cm"))) +
   geom_vline(xintercept = c(0), color = "grey70", linetype = 2) +
   geom_hline(yintercept = c(0), color = "grey70", linetype = 2) +
  geom_text(data = ccavectors, aes(x = CAP1*1.5, y = CAP2*1.5, 
                                   label = rownames(ccavectors)),
                                   #nudge_x = 0.3, nudge_y = 0.3
                                   size=6 ) +
  theme_bw() +
  scale_fill_manual(values= pal3) +
  scale_color_manual(values=pal3) +
  labs(x = "CAP1 [1.6%]", y="CAP2 [0.7%]") +
  stat_ellipse(aes(color=cat), size = 1, alpha = 0.5) + 
  #stat_ellipse(aes(fill = cat), geom="polygon", level=0.95, alpha=0.09) +
  labs( color = "Temperature \ncategory", fill = "Temperature category", 
        title = "Bray distances of hellinger transformed samples (n = 191), 180 classes.") +
  
     theme(legend.background = element_blank(),
           legend.box.background = element_rect(colour = "gray")) 

plot_cca


```



# PART IV: DS
```{r}
#| eval: false


# the DS dataset from EVA
Eva_master <- read_excel("C:/Users/Angela Cukusic/Desktop/Downloads/2022_Masterjoints.xlsx")
Eva_master$sample_season <- paste(Eva_master$Probennr, 
                                  "spring" , sep = "_")

# just spring DS data
main_sheet <- read.csv("C:/Users/Angela Cukusic/Desktop/Master thesis/data/main_sheet.csv")
main_sheet$sample_season <- paste(main_sheet$Sample.ID, 
                                  main_sheet$Season, sep = "_")
data_DS <- left_join(Eva_master, main_sheet, by = "sample_season") %>% 
            dplyr::filter(grepl('DS', Geol_beb)) 
data_DS <- ens2 %>% rownames_to_column("JMF.ID") %>% right_join(., data_DS, by ="JMF.ID")

################################################

add_data3 <- read_excel("C:/Users/Angela Cukusic/Desktop/Downloads/2022_01_31_Daten_Andela(1).xlsx")
data_DS <- add_data1[, c("Sample_ID", "Name_HBC")] %>% 
  full_join(., add_data3,  by = "Name_HBC") %>% 
  dplyr::select(!"Name_HBC") %>% left_join(data_DS , . , 
                                           by = c("Sample.ID" = "Sample_ID"),
                                           relationship = "many-to-many") 
data_DS["heatsources_UHI"] <- lapply(data_DS["heatsources_UHI"], as.factor) 
data_DS["heatsources_GWWP"] <- lapply(data_DS["heatsources_GWWP"], as.factor) 
data_DS["heatsources_FW"] <- lapply(data_DS["heatsources_FW"], as.factor) 
data_DS["heatsources_Versie"] <- lapply(data_DS["heatsources_Versie"], as.factor) 
data_DS["heatsources_count"] <- lapply(data_DS["heatsources_count"], as.factor) 
data_DS["OF_beb"] <- lapply(data_DS["OF_beb"], as.factor) 

#add it to new_metadata
new_metadata <- add_data1[, c("Sample_ID", "Name_HBC")] %>% 
  full_join(., add_data3,  by = "Name_HBC") %>% 
  dplyr::select(!"Name_HBC") %>% left_join(new_metadata , . , 
                                           by = c("Sample.ID.x" = "Sample_ID"),
                                           relationship = "many-to-many") 
new_metadata["heatsources_UHI"] <- lapply(new_metadata["heatsources_UHI"], as.factor) 
new_metadata["heatsources_GWWP"] <- lapply(new_metadata["heatsources_GWWP"], as.factor) 
new_metadata["heatsources_FW"] <- lapply(new_metadata["heatsources_FW"], as.factor) 
new_metadata["heatsources_Versie"] <- lapply(new_metadata["heatsources_Versie"], as.factor) 
new_metadata["heatsources_count"] <- lapply(new_metadata["heatsources_count"], as.factor) 



#just for spring


#combining eva master to shannon needs the HBT name to JMF
#of_beb

# add HBT_name to the Sample ID
new_metadata <- add_data1[, c("Sample_ID", "Name_HBC")] %>% 
  left_join(new_metadata, .,  by = c("Sample.ID.x" = "Sample_ID"))

full_data1  <-   ens2 %>% 
  rownames_to_column("JMF.ID") %>% 
  left_join(new_metadata,. , by = "JMF.ID") %>% 
  dplyr::select("Name_HBC"  , "Shannon")
  

Eva_master <- read_excel("C:/Users/Angela Cukusic/Desktop/Downloads/2022_Masterjoints.xlsx")



data <- full_data1 %>% 
  right_join(., Eva_master,  by = "Name_HBC") %>% 
 dplyr::filter(grepl('DS', Geol_beb)) 
data$OF_beb[data$OF_beb == 3] <- 0 #changing the 3s to 0
data["OF_beb"] <- lapply(data["OF_beb"], as.factor) 

split_labels <- str_wrap(c("no effect", "running water effect", "stagnant water effect"), width = 8)

p1 <- data %>% dplyr::filter(OF_beb != "NA") %>% 
  ggplot(aes(x=OF_beb, y=Shannon)) + geom_boxplot(fill = "gray", alpha=0.5) +
  theme_bw() + labs(x="Surface water impact", y= "Shannons diversity index") +
  scale_x_discrete(labels = split_labels)



shapiro.test (data_for_alpha2[which(data_for_alpha2$GWWP == "1"),"ens"] ) # norm
shapiro.test ( data_for_alpha2[which(data_for_alpha2$GWWP == "0"),"ens"]) # norm
bartlett.test(ens ~ GWWP, data= data_for_alpha2) # homo
summary( aov(ens ~ GWWP, data= data_for_alpha2) )




#wastewater
data["wastew_beb"] <- lapply(data["wastew_beb"], as.factor) 

  p2 <- data %>% 
 #dplyr::filter(OF_beb != "NA") %>% 
  ggplot(aes(x=wastew_beb, y=Shannon)) + geom_boxplot(fill = "gray", alpha=0.5) +
 theme_bw() + labs(x="Waste water impact", y= "Shannons diversity index") +
 scale_x_discrete(labels = c("no effect", "effect present", "unclear"))

p1 + p2

#redox
data["Redox_beb"] <- lapply(data["Redox_beb"], as.factor) 

split_labels <- str_wrap(c("o2 > 2", "o2 < 2", "Mn>0.15 & Fe>0.15", "s>0.1"), width = 8)

p3 <- data %>% 
 dplyr::filter(Redox_beb != "NA") %>% 
  ggplot(aes(x=Redox_beb, y=Shannon)) + geom_boxplot(fill = "gray", alpha=0.5) +
  theme_bw() + labs(x="Redox cascade", y= "Shannons diversity index") +
 scale_x_discrete(labels = split_labels )
                     


p1 + p2 +p3



##################################################################

data2 <- left_join(data, new_metadata[which(new_metadata$Season == "spring"),c("JMF.ID", "Name_HBC")], by = "Name_HBC")
unique_values  <-  unique(data2$JMF.ID)
data3 <- data2[!duplicated(data2$JMF.ID,  fromLast = TRUE), ] 
data3 <- data3[which(data3$JMF.ID != "NA"), ] 

data3[order(data3$JMF.ID), ]

rownames(data3) <- data3$JMF.ID
asv_ds_spring <- srs_asv_all[, which(colnames(srs_asv_all) %in% rownames(data3))]


#categorise by temperature groups
data3$Cat3 <- cut(data3$T_cali, 
                         breaks=c(0, 10, 12, 14, 16, 18, 20, 30), 
                         labels=c('<10', '10-12', '12-14', '14-16', 
                                  '16-18', '18-20', '20<'))
# find reference samples (the one in Marchfeld)
reference <- new_metadata %>% 
  filter(sample_season %in% c("22-246_fall", "EM10_spring",  "EM62_spring", "22-52_fall", 
                              "22-52_spring", "22.7/2_spring", "22.7/2_fall"))

# distinguish reference samples from the 10-12C
data3 <- data3 %>%
  mutate( reference = case_when(JMF.ID %in% reference$JMF.ID ~ "referential", 
                                TRUE ~ "other")) 
data3$ref_cat <- paste(data3$Cat3, data3$reference, sep="_")
data3 <- data3 %>% 
  mutate( category = case_when(ref_cat == "<10_other" ~ "<10",
                               ref_cat == "10-12_other" ~ "10-12",
                               ref_cat == "12-14_other" ~ "12-14",
                               ref_cat == "14-16_other" ~ "14-16",
                               ref_cat == "16-18_other" ~ "16-18",
                               ref_cat == "18-20_other" ~ "18-20",
                               ref_cat == "20<_other" ~ "20<",
                               TRUE ~ "ref_cat")) %>% 
  dplyr::select(!c("Cat3" , "reference" ,    "ref_cat"))
#at this point 281 samples







ps_all <- phyloseq(otu_table(as.matrix(asv_ds_spring), taxa_are_rows=TRUE), 
                   tax_table(as.matrix(new_taxonomy) ) , 
                  sample_data(as.data.frame(data3)) )

ps_all <- prune_taxa(taxa_sums(ps_all) > 0, ps_all)

```


## ordination
```{r}
#| eval: false

# perform ordination
unconstrained_aitchison_pca <- ps_all %>% tax_fix() %>% 
  tax_filter(min_prevalence = 0.1, tax_level = "Genus") %>%
  tax_agg("Family") %>%
  tax_transform("clr") %>%
  ord_calc()
 #ord_calc will automatically infer you want a "PCA" here
 #specify explicitly with method = "PCA", or you can pick another method

# create plot
pca_plot <- unconstrained_aitchison_pca %>%
 ord_plot(
    plot_taxa = 1:6, colour = "bmi_group", size = 1.5,
   tax_vec_length = 0.325,
  tax_lab_style = tax_lab_style(max_angle = 90, aspect_ratio = 0.5),
 auto_caption = 8)

# customise plot
customised_plot <- pca_plot +
  stat_ellipse(aes(linetype = bmi_group, colour = bmi_group), linewidth = 0.3) + # linewidth not size, since ggplot 3.4.0
  scale_colour_brewer(palette = "Set1") +
theme(legend.position = "bottom") +
coord_fixed(ratio = 0.5, clip = "off") # makes rotated labels align correctly

# show plot
customised_plot




```


```{r}
#| eval: false

data_for_reg <- cbind(new_metadata) %>% dplyr::select(where(is.numeric)) %>% 
 scale(center = T, scale = T) %>% cbind(., richness, ens) %>% data.frame() %>% 
dplyr::select(! c("DIC", "SO4", "Cl", "Na", "Ca", "Mg", "Lf", "richness",
                 "NO3", "NH3", "Fe", "X", "Y", "DOM_bix") )


nullModel = lm(ens ~ 1, data=data_for_reg) # model with the intercept only
fullModel = lm(ens ~ ., data=data_for_reg) # model with all  variables

#choose
step.model<-stepAIC(fullModel, # start with a model containing no variables
                   direction = 'both', # run forward selection
                  trace = 0) # dont show step-by-step process of model selection
summary(step.model) # only temp significant
RsquareAdj(step.model) # 0.04038098 -> 4 %
summary(lm(ens ~ Temp, data = data_for_reg)) 


### other models ####


# categorical variables
new_metadata %>% dplyr::select(!where(is.numeric)) 

# turn NAs from OF_beb into 0
new_metadata["OF_beb"] <- lapply(new_metadata["OF_beb"], as.character)
# Replace NA with 0
new_metadata[is.na(new_metadata)] <- 0 
# Change character columns back to factors
new_metadata["OF_beb"] <- lapply(new_metadata["OF_beb"], as.factor) 

# another thing needs fixing:
# add data about heat sources i forgot before
add_data3 <- read_excel("~/Desktop/DS_analysis/data/heat_sources.xlsx")
new_metadata <- add_data1[, c("Sample_ID", "Name_HBC")] %>% 
 full_join(., add_data3,  by = "Name_HBC") %>% 
dplyr::select(!"Name_HBC") %>% left_join(new_metadata, . , 
                                        by = c("Sample_ID.x" = "Sample_ID") ) 
new_metadata["heatsources_UHI"] <- lapply(new_metadata["heatsources_UHI"], as.factor) 
new_metadata["heatsources_GWWP"] <- lapply(new_metadata["heatsources_GWWP"], as.factor) 
new_metadata["heatsources_FW"] <- lapply(new_metadata["heatsources_FW"], as.factor) 
new_metadata["heatsources_Versie"] <- lapply(new_metadata["heatsources_Versie"], as.factor) 
new_metadata["heatsources_count"] <- lapply(new_metadata["heatsources_count"], as.factor) 

boxplot(richness ~ new_metadata$Geol_beb)
boxplot(richness ~ new_metadata$heatsources_UHI) # according to how many heat sources impact well
summary(aov(richness ~ category*Land.use*season*Geol_beb*UHI*heatsources_UHI, data=new_metadata) ) 
# category:Geol_beb:heatsources_UHI interaction significant
#summary(aov(richness ~ category:Geol_beb:heatsources_UHI, data=new_metadata) )
#fit3 <- lm(richness ~ category:Geol_beb:heatsources_UHI, data=new_metadata) 
#summary(fit3 ) # not sign


# plot interactions
#cat_plot(fit3, pred = Geol_beb, modx = heatsources_UHI, geom = "line")



# the same but for ens
#boxplot(ens ~ new_metadata$Geol_beb)
#boxplot(ens ~ new_metadata$UHI)
#summary(aov(ens ~ category*Land.use*season*Geol_beb*UHI, data=new_metadata) ) 
# category + UHI + Land.use:UHI significant
#model_ens <- aov(ens ~ category + UHI + Land.use:UHI, data=new_metadata) 
#summary(model_ens)
# i should do a kruskal wallis?






```

