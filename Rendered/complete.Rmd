---
title: "The impact of groundwater temperature on the composition of groundwater microbial communities in an urban aquifer" 
author:  "Angela Cukusic"
output:
  html_document:
    toc: true               # Table of contents
    toc_float: true         # Keep the table of contents floating on the page
    code_download: true     # Enable code download button
    code_copy: true         # Enable code copy button
    number_sections: true   # Numbering the sections
    theme: cerulean           # Choose a Bootstrap theme (check available themes)
    highlight: tango        # Syntax highlighting style 
---

```{r setup, include=FALSE}
# For width of code chunks and scroll bar 
options(width=250)

knitr::opts_chunk$set(eval = TRUE, 
                      echo = TRUE, 
                      cache = TRUE,
                      include = TRUE,
                      warning = FALSE,
                      collapse = FALSE,
                      message = FALSE,
                      engine = "R", 
                      # Chunks will always have R code, unless noted
                      error = TRUE)

```

# Load packages

```{r load-libraries}
library(tidyverse)
library(stringr)
library(broom)
library(rstatix)      # tidyverse-compatible statistical testing
library(ggpmisc)      # adding equation on ggplots
library(vegan)
library(patchwork)    # combining plots in a single figure
library(ggpubr)       # cleaner plotting and for stat_corr
library(MASS)
library(ggfortify)
library(ggrepel)

 
# coordianate plotting
library(mapview)     
library(sf)           
library(geosphere)    



# Set the ggplot theme 
theme_set(theme_linedraw())
```

# Load data

The data has been prepared for analysis with four script in the same repository.
The metadata has been cleaned of unnecessary variables, as well as combined together from both the spring and fall sampling campaing.
It has, furthermore, been decontaminated by the decontam package, the contaminants and blanks were then removed from the count table, replicates of the same sampling site were summed up, and, finally, the temperature categorisation has been added as a variable.

The final count table and taxonomy table (no contaminat ASVs and no blank samples) and clean metadata info is here loaded in.

```{r data-load}

# a) final metadata
metadata <- read.csv("C:/Users/Angela Cukusic/Desktop/DS_analysis/data/master_data.csv") %>% 
  dplyr::select(-"X.1") %>% dplyr::filter(Type != "SW")

# b) final asv_table
asv_table <-read.csv("C:/Users/Angela Cukusic/Desktop/DS_analysis/data/asv_table_final.csv",
                     check.names = FALSE, row.names = 1)
asv_table <- asv_table[, colnames(asv_table) %in% metadata$sample_season]

# c) final taxonomy table
tax_table <- read.csv("C:/Users/Angela Cukusic/Desktop/DS_analysis/data/tax_no_cont.csv",  row.names = 1)


```

The palettes for the temperature categories color scheme (blue to red; cold to warm) and composition (25 colors distinct from one another to differentiate between taxa abundances).

```{r palette-load}
# color palettes
pal3 = c("#253494", "#225ea8", "#1d91c0", "#7fcdbb" , 
         "#fdbb84", "#d7301f", "#7f0000", "gray")

c25 <- c("dodgerblue2", "#E31A1C", "green4" ,  "#6A3D9A",     "skyblue2", 
         "blue1", "gold1", "brown",  "#FB9A99", "steelblue4" ,  "palegreen2" , 
         "#CAB2D6", "#FDBF6F", "khaki2",  "maroon",  "gray70",  "orchid1",  
         "deeppink1",  "darkorange4",  "green1",  "yellow4"  ,    "yellow3",  
         "beige", "darkturquoise", "#FF7F00" )

name_vector <- c( "ref_cat", "<10", "10-12", "12-14", "14-16", 
                      "16-18",  "18-20",  "20<" )

```

# Analysis

## Alpha diversity

### Temperature distribution

```{r alpha-temp}

# Shannon's index 
shannondiv <- vegan::diversity(t(asv_table))
# turning Shannon's index to effective number of species to be more comparable across studies 
ens <- exp(shannondiv)

p1_en <- cbind(as.data.frame(ens), as.factor(metadata$category)) %>% 
  as.data.frame() %>%
  rename("div"= "ens",
         "temp"="as.factor(metadata$category)") %>%
  filter(temp != "NA") %>% 
# plot
  ggplot( aes(x = temp, y = div, fill = temp)) +
  geom_jitter(width = 0.2, size = 3, shape=21, aes(fill = temp) ) +
  geom_boxplot(alpha=0.5, outlier.shape = NA) +
# add custom palette  
  scale_fill_manual(values = pal3) +
# make  the figure more readable  
  theme(legend.position = "none",
        axis.title=element_text(size=14,face="bold"),
        axis.text.y = element_text(size=10,face="bold"),
        axis.text.x = element_text(angle = 90)) +
  labs(x = "Temperature category",
       y = "Shannon diversity index",
       title = "Diversity by temp. categories") +
  scale_x_discrete(limits = name_vector)  


```

Testing if the distribution of alpha diversity per temperature categories is significant and can be added to the figure in a "\*" form.

```{r alpha-test}

# perform ANOVA?
## 1. assumption: Normal distribution: 
## Each population to be compared should be normally distributed 

cbind( as.data.frame(ens), metadata$category) %>%
  rename("cat" = "metadata$category" ) %>% 
  filter(cat != "NA") %>% 
  group_by(cat) %>% 
  do(tidy(shapiro.test(.$ens)))

# would be better to do a non-parametric test
# since >20 is not normally distributed

## 2. assumption: Homogeneity of variance: 
## Variance in the populations compared should be the same/similar. 
cbind( as.data.frame(ens), metadata$category) %>%
  rename("cat" = "metadata$category" ) %>% 
  filter(cat != "NA") %>% 
  levene_test(ens ~ cat) %>% 
  dplyr::select("p") 
# assumption met
# but irrelevant

# do non-parametric anova
cbind( as.data.frame(ens), metadata$category) %>%
  rename("cat" = "metadata$category" ) %>% 
  filter(cat != "NA") %>% 
  kruskal_test(ens ~ cat)
# significant difference between groups

# do post-hoc to see which
cbind( as.data.frame(ens), metadata$category) %>%
  rename("cat" = "metadata$category" ) %>% 
  filter(cat != "NA") %>% 
  dunn_test(ens ~ cat)
# post-hoc does not show difference
# so no adding to the plot

```

To see if there is a linear trend that gets obscured by the grouping:

```{r alpha-lin}

p1_en_li <- cbind(as.data.frame(shannondiv), metadata$Temp) %>% 
  as.data.frame() %>%
  rename("div"= "shannondiv","temp"="metadata$Temp") %>%
  filter(temp != "NA") %>% 
# plot
  ggplot(aes(temp,div)) + 
  geom_point(shape=21, size = 3, fill = "violet", alpha = 0.9, stroke = 0.6) + 
  geom_smooth(method = "lm", se= FALSE, color = "black") + 
  ggpmisc::stat_poly_eq(use_label(c("eq", "adj.R2", "p")), 
                        label.y = "bottom", size = 3) + 
  labs(y = "Shannon diversity index", x ="Temperature", 
       title = "Linear trend in diversity index") +
  theme(legend.position = "none",
        axis.title=element_text(size=14,face="bold"),
        axis.text.y = element_text(size=10,face="bold"),
        axis.text.x = element_text(angle = 90)) 

p1_en + p1_en_li
```

### Spatial distribution

Plot the diversity index on an interactive map to see if there is a geographical pattern to the alpha diversity.

```{r alpha-spatial}

# add mapview to change X and Y to standard crs
new_metadata2 <- metadata %>% 
  cbind(., as.data.frame(ens)) %>% 
  filter(Temp != "NA") %>% 
# add small value to coordinates for one of the campaigns
# so they do not overlap completely on the map  
  mutate(X = ifelse(grepl("fall", sample_season) , X + 45, X)) %>% 
  dplyr::select("ens", "X", "Y") %>% 
  drop_na() %>% 
  mutate( ens_cat = cut(ens, b=6) )  


pal <-  mapviewPalette("mapviewSpectralColors")

sf_data <- st_as_sf(new_metadata2, coords = c("X", "Y"),  crs = 31253)
mapview(sf_data,  map.types = "Stamen.Terrain", col.regions = pal(10),
        zcol= "ens_cat", zoom = 12, color="black", 
        cex = 5, alpha = 0.7 ) 
```

### Aquifer distributuion

We chose all the aquifers that had more than 5 sampling points to see whether there is an impact of aquifer categorisation on the diversity index.

```{r alpha-aquifer}

cbind( metadata, ens ) %>% 
# filter out >5 aquifers
  dplyr::filter(! Geol_beb %in%  c("n.b.", "lokaler Aquifer",
                                   "Wiental", "Zubringer", "OF")) %>% 
# do not differentiate between the different Donauschotter samples 
                mutate(Geol_beb = case_when( 
                            grepl('DS', Geol_beb) ~ "Donauschotter", 
                                              TRUE ~ Geol_beb)) %>% 
  dplyr::select("ens", "Geol_beb", "Temp") %>% 
  na.omit() %>% 
# plot
  ggplot(aes(x=Temp, y=ens)) + 
  geom_point(shape=21, size = 3, fill = "violet", alpha = 0.9, stroke = 0.5) + 
  geom_smooth(method = "lm", se= FALSE, color = "black") +
  facet_wrap(~ Geol_beb, scales = "free_y", ncol = 2) + 
  #stat_poly_line() +
  stat_poly_eq(use_label(c("eq", "adj.R2", "p")), 
               label.y = "bottom",
               size = 3) + 
  labs(x = "Temperature",
       y = "Sshannon's diversity index") +
  theme(axis.title.x = element_text(hjust = 0), 
        legend.position = "none",
        axis.title=element_text(size=14,face="bold"),
        axis.text.y = element_text(size=10,face="bold"),
        axis.text.x = element_text(angle = 90),
        strip.text = element_text(size = 12))

```

### Modelling

What environmental variables significantly impact alpha diversity:

```{r alpha-model}

df_alpha <- metadata %>%  
  cbind(as.data.frame(ens)) %>% 
  dplyr::select(where(is.numeric)) %>% 
  dplyr::select(-c("NH4", # many NAs
            "X", "Y")) %>% # coordinates
  na.omit() %>% 
  scale(center = T, scale = T) %>% 
  as.data.frame()
 

# remove the highly correlated ones
cor_matrix <- cor(df_alpha)
highly_correlated <- caret::findCorrelation(cor_matrix, cutoff = 0.9)
df_alpha <- df_alpha[, -highly_correlated] 

# run individual regressions for each variable
varlist <- names(df_alpha)[-19]
models <- lapply(varlist, function(x) {
    form <- formula(paste("ens ~", x))
    lm(form, data=df_alpha)
})
# tidy up the results
lapply(models, function(x) tidy(x)) %>% bind_rows() -> ind_models
ind_models %>% filter(term != "(Intercept)") %>% filter(p.value<0.05)
# none are sign

```

Only variables which have a significant individual effect are Calcium and well depth, however, they do not have a good model fit.
Let's see if there is a better fit of multiple refression:

```{r alpha-model-combined}


fullModel = lm(ens ~ ., data=df_alpha) # model with all  variables

# remove high vif variables
car::vif(fullModel)  %>% as.data.frame() %>% 
  dplyr::rename("vif"=".") %>% 
  filter(vif<10)  %>% 
  rownames_to_column("envs") %>% 
  dplyr::select("envs")  -> colnames

df_alpha2 <- df_alpha %>% dplyr::select("ens", 
                                       which(colnames(df_alpha) %in% colnames$envs ))

fullModel = lm(ens ~ .  , data = df_alpha2) # model with all  variables


#choose
step.model<- MASS::stepAIC(fullModel, # start with a model containing no variables
                    direction = 'both', # run forward selection
                    trace = 0) # dont show step-by-step process of model selection

#summary(step.model) # none
RsquareAdj(step.model) # <2%

```

## Composition

### Bar plot

```{r comp-bar}

#detach(package:plyr, unload = TRUE)

asv_table %>% 
  mutate_if(is.integer, as.numeric) %>% 
  mutate(class = tax_table$Class) %>%
  pivot_longer(cols = -class, values_to = "abundance", names_to = "sample") %>%
  left_join(.,metadata, by = c("sample" = "sample_season")) %>%  
  dplyr::select ("abundance", "class", "category") %>%
# to remove those with no category
  dplyr::filter(category != "NA") %>% 
# to make NA classes Unclassified   
  replace_na(list(class ='Unclassified' )) %>%
  mutate(category = as.factor(category),
         class = as.factor(class)) %>%  
# to find relative abundance within each category  
  dplyr::group_by(category) %>%
  mutate (rel_abund = abundance / sum(abundance)) %>%
  ungroup() %>%
# to sum up all the counts of one class from all the samples  
  dplyr::group_by(category, class) %>%
  summarise(rel_abund = sum(rel_abund)) %>%
  ungroup() %>%
# those very rare categorize as Diverse others 
  dplyr::group_by(category, class) %>%
  mutate(class = case_when(rel_abund< 0.015~ "Diverse others", 
                           TRUE ~ class)) %>%
  ungroup() %>%
# final regrouping after categorizing for Diverse others  
  dplyr::group_by(category, class) %>%
  summarise(rel_abund = sum(rel_abund)) %>%
  ungroup() %>%

# plot
  ggplot(aes(x = category, y = rel_abund, fill = class)) + 
  geom_bar(stat = "identity", color = "black") +
  scale_fill_manual(values=c25) +
  theme(panel.grid = element_blank(), legend.position="right",
        legend.text = element_text(size = 6),      # Adjust the text size
        legend.title = element_text(size = 6),
        legend.key.size = unit(0.4, "cm"),
        axis.title=element_text(size=14,face="bold"),
        axis.text.y = element_text(size=10,face="bold"),
        axis.text.x = element_text(angle = 90, face = "bold")) + 
  labs(x = "Temperature categories",
       y = "Relative abundance", 
       fill = "Class") +
  guides(fill=guide_legend(ncol = 1)) +
  scale_x_discrete(limits = name_vector) 

```

### Bubble plot

```{r comp-bubble}

asv_table %>% 
  mutate_if(is.integer, as.numeric) %>% 
  mutate(class = tax_table$Class) %>%
  pivot_longer(cols = -class, values_to = "abundance", names_to = "sample") %>%
  left_join(.,metadata, by = c("sample" = "sample_season")) %>%  
  dplyr::select ("abundance", "class", "category") %>%
# to remove those with no category
  dplyr::filter(category != "NA") %>% 
# to make NA classes Unclassified   
  replace_na(list(class ='Unclassified' )) %>%
  mutate(category = as.factor(category),
         class = as.factor(class)) %>%  
# to find relative abundance within each category  
  dplyr::group_by(category) %>%
  mutate (rel_abund = abundance / sum(abundance)) %>%
  ungroup() %>%
# to sum up all the counts of one class from all the samples  
  dplyr::group_by(category, class) %>%
  summarise(rel_abund = sum(rel_abund)) %>%
  ungroup() %>%
# those very rare categorize as Diverse others 
  dplyr::group_by(category, class) %>%
  mutate(class = case_when(rel_abund< 0.015~ "Diverse others", 
                           TRUE ~ class)) %>%
  ungroup() %>%
# final regrouping after categorizing for Diverse others  
  dplyr::group_by(category, class) %>%
  summarise(rel_abund = sum(rel_abund)) %>%
  ungroup() -> data
  
# plot  
data %>% 
  ggplot(aes(x = as.factor(category), y = as.factor(class) )) + 
  geom_point(aes(size = rel_abund, fill=class ), 
             alpha = 0.8, shape = 21, stroke = 0.5) + 
  scale_size_continuous(limits = c(0.001, 0.4), range = c(1,7)) + 
  labs( x= "", y = "", size = "Relative Abundance", fill = "")  + 
  theme(legend.key=element_blank(), 
        axis.text.x = element_text(colour = "black", size = 7, face = "bold", 
                                   angle = 90, vjust = 0.3, hjust = 1),
        axis.text.y = element_text(colour = "black", face = "bold", size = 11), 
        legend.text = element_text(size = 7, face ="bold", colour ="black"), 
        legend.title = element_text(size = 7, face = "bold"), 
        legend.position = "right") +  
  scale_fill_manual(values = c25, guide = "none") +   
  scale_y_discrete(limits = rev(levels(data$class))) +
  scale_x_discrete(limits = name_vector) 

```

```{r mean-sd}

# i usually do it with phyloseq, try to do it manually
#ps_for_sd <- tax_glom(ps_all, "Class") %>% 
#  transform_sample_counts(., function(x) x/sum(x))

#tb <- psmelt(ps_for_sd) %>%  as_tibble

# manually:
asv_table %>% 
  mutate_if(is.integer, as.numeric) %>% 
  mutate(class = tax_table$Class) %>%
  pivot_longer(cols = -class, values_to = "abundance", names_to = "sample") %>%
# to make NA classes Unclassified   
  replace_na(list(class ='Unclassified' )) %>%
  mutate(class = as.factor(class)) %>% 
# to get relative values
  dplyr::group_by(class) %>%
  mutate (rel_abund = abundance / sum(abundance)) %>%
  ungroup() %>% 
  group_by(class) %>%
  dplyr::summarize( Mean = mean(rel_abund), SD = sd(rel_abund) ) %>%
  ungroup() %>% 
  mutate( Mean_per = .$Mean *100, sd_per = .$SD *100 )  %>% 
  dplyr::filter( Mean_per > 1 ) %>% 
  left_join(., 
            distinct( tax_table[, c("Kingdom", "Phylum", "Class")], Class , 
                      .keep_all = TRUE ) ,
            by=c("class" = "Class") ) 

# not great
tb0 <- tb %>%
  group_by(Class) %>%
  dplyr::summarize( Mean = mean(Abundance), SD = sd(Abundance) ) %>%
  ungroup() %>% 
  mutate( Mean_per = .$Mean *100, sd_per = .$SD *100 )  %>% 
  dplyr::filter( Mean_per > 1 ) %>% 
  left_join(., 
            distinct( new_taxonomy[, c("Kingdom", "Phylum", "Class")], Class , 
                      .keep_all = TRUE ) ,
            by="Class") 

head(tb0[order(tb0$Mean_per), c("Class", "Mean_per", "sd_per", "Phylum")])
head(tb0[, c("Class", "Kingdom", "Phylum")] )

```

### Mathano-gens/trophs 

Considering the high methane concentrations in Vienna, we tried connecting the concentrations to the taxa which are connected to the methane processes.


```{r comp-diff}

# 1. clean taxonomy
# subset the "Methylo-" and "Methano-" taxa at the order level
tax_table %>% rownames_to_column("asv") %>%   
# filter the methane taxa
dplyr::filter(grepl('Meth', Order)) %>% 
dplyr::select("asv", "Order")  -> tax_meth


# 2. clean asv_table
# choose only the asvs from the selected orders
asv_table[which(rownames(asv_table) %in% tax_meth$asv ),] %>% 
# only spring has CH4 measures, select spring samples
  rownames_to_column("asv") %>% 
  pivot_longer(cols = -asv, names_to = "samples", values_to = "abundances") %>% 
# filter only the spring samples
dplyr::filter(grepl('spring', samples)) %>%   
# connect to the order information  
  left_join(., tax_meth, by = "asv") %>% 
  dplyr::select("samples", "Order", "abundances") %>% 
  group_by(samples, Order) %>% 
# sum up the abundance within each order (diff sp/taxa)  
  summarise(abund = sum(abundances)) %>% 
  ungroup() %>% 
# connect the asv data to the metadata (methane level)
  left_join(., metadata[,c("sample_season", "CH4")], by = "sample_season") %>% 

# find correlation for each order to see which are significant
  group_by(Order) %>%
  cor_test(CH4, abund) %>% 
  ungroup() %>% 
  
  
# plot only significant
ggplot(aes(x = CH4 , y = abund)) +
  geom_point(shape=21, size = 3, fill = "violet", alpha = 0.9, stroke = 0.5) + 
  geom_smooth(method = "lm", se= FALSE, color = "black") +
  facet_wrap(~ Order, scales = "free_y", ncol = 2) + 
  #stat_poly_line() +
  stat_poly_eq(use_label(c("eq", "adj.R2", "p")), 
               label.y = "bottom",
               size = 3)
  



# now remove tax_meth since we no longer need it
rm(tax_meth)

```

## Beta diversity

### Temperature distribution

```{r nmds-temp}
# tax clean
tax_table %>% rownames_to_column("asv") -> tax_tab

# aggregate to genus level
asv_table %>% 
  rownames_to_column("asv") %>% 
  pivot_longer(cols = -asv, names_to = "samples", values_to = "abundances") %>% 
  left_join(., tax_tab, by = "asv") %>% 
  dplyr::select("samples", "Genus", "abundances") %>% 
  group_by(samples,  Genus) %>% 
  summarise(sum(abundances)) %>% 
  ungroup() %>% 
  replace_na(list(Genus ='Unclassified' )) %>%
  pivot_wider(names_from = "samples", values_from = "sum(abundances)") %>% 
  column_to_rownames("Genus") -> asv_aggregated



# do an ordination
sp.dist <-  vegdist(decostand( t(asv_aggregated),  method = "hellinger") )
# or without the transformation
# sp.dist <-  vegdist(t(asv_aggregated))
nmds <- metaMDS(sp.dist, k = 2, autotransform = FALSE)

```

```{r nmds-plot}

# plot it 
nmds_plot <- as.data.frame(nmds$points) %>% 
  cbind(., as.factor(metadata$category)) %>% 
  dplyr::rename("cat" = "as.factor(metadata$category)") %>%
  filter(cat !=  "NA") %>% 
  ggplot(aes(x=MDS1,y=MDS2) ) +
  geom_point(aes( fill= cat), shape = 21, 
             size = 4, alpha = 0.6, stroke = 0.5) +  
  scale_color_manual(values=pal3) +
  scale_fill_manual(values=pal3) +
  annotate(geom="text",x=0.8, y=0.7, label="stress =", color="black") +   
  annotate(geom="text", x=1.1, y=0.7, label=round(nmds$stress,4), color="black") +
  stat_ellipse(aes(colour = cat), linewidth = 0.4) + 
  theme(legend.background = element_blank(),
        legend.box.background = element_rect(colour = "gray")) +
  labs(fill = "Temperature \ncategory") +
  guides(color = "none") +
  geom_vline(xintercept = c(0), color = "grey70", linetype = 2) +
  geom_hline(yintercept = c(0), color = "grey70", linetype = 2) 

nmds_plot
  
```

test ordination

```{r nmds-test}

# 1. test dispersion as an assumption (variance test for multivariate statitics)
disp <- betadisper( sp.dist, metadata$category ) 

#p>0.05 is what we need - homogenous variances
anova(disp) #no sign. differences in dispersion
# if there was sign, i would check with this which one are they
# TukeyHSD(disp) 



# 2. now test actual ordination
# test differences in group centroid with adonis (anova version for multivariate statistics)
permanova <- adonis2(sp.dist ~ metadata$category, na.action = na.omit,
                    method = "bray" , permutations = 999)
permanova # not sign.



# if it was significant i would test which groups are significantly different
#pair_res <- pairwiseAdonis::pairwise.adonis2(t(asv_aggregated) ~ category, data = new_metadata)


```

### Spatial distribution

```{r beta-spatial}
# data with only the coordinates known
data_coo <- metadata %>% 
      dplyr::select("sample_season", "X","Y") %>% 
      na.omit() 

gg <- data_coo %>% 
      st_as_sf(., coords = c("X", "Y"), crs = 31253) %>% 
      st_set_crs(31253) %>% 
      st_transform(4326) %>% 
      st_coordinates() %>%
      as.data.frame() %>%
      distm(., fun = distHaversine) %>%
      as.dist(.) %>% as.vector()

aa <- asv_table[, colnames(asv_table) %in% data_coo$sample_season] %>%  
      t() %>% 
      vegdist(., method = "bray") %>%
      as.vector()


matr <- data.frame(gg, aa)

ggplot(matr, aes(y = gg, x = aa)) + 
  geom_point(size = 3, alpha = 0.9, color="black", 
             shape = 21, fill= "violet",size = 5 ) +
  geom_smooth(method = "lm", colour = "black", alpha = 0.2) +
# add correlation info  
  ggpubr::stat_cor(method = "spearman",  
                   label.y.npc="top", 
                   label.x.npc = "left",
                   color="black", size=4) +
# edit visualization  
  labs(x = "Community dissimilarity", 
       y = "Physical Separation (km)") + 
  theme( axis.text.x = element_text(face = "bold",
                                    colour = "black", size = 12), 
         axis.text.y = element_text(face = "bold", 
                                    size = 11, colour = "black"), 
         axis.title = element_text(face = "bold", 
                                  size = 14, colour = "black")) +
# to turn y scale to kms
  scale_y_continuous(breaks = seq(0, 30000, by = 5000),
                     labels = function(x) x / 1000) 



```

### Aquifer distribution

```{r beta-aquifer}

cbind(metadata, as.data.frame(nmds$points) ) %>% 
dplyr::filter(! Geol_beb %in%  c("n.b.", "lokaler Aquifer",
                                   "Wiental", "Zubringer", "OF")) %>% 
dplyr::select("Geol_beb") %>% 
  na.omit() -> data_aq


# first test assumption: equal dispersion
disp_aq <- betadisper( 
  vegdist(t(  asv_aggregated[,which(colnames(asv_aggregated) %in% rownames(data_aq))] ),
          method = "bray"), 
          data_aq$Geol_beb ) 

#p>0.05 is what we need - homogenous variances
anova(disp_aq) #no sign. differences in dispersion
#TukeyHSD(disp) # if there was sign, i would check with this which one are they


# now test actual ordination
permanova_aq <- adonis2(t( asv_aggregated[,which(colnames(asv_aggregated) %in% rownames(data_aq))] ) ~ 
                        data_aq$Geol_beb, 
                         method = "bray" , 
                        permutations = 999)
permanova # not sign


```

## Environmental data

```{r env-data}
# as done before:
df_alpha <- metadata %>%  
  column_to_rownames("sample_season") %>% 
  dplyr::select(where(is.numeric)) %>% 
  dplyr::select(-c("NH4", # many NAs
            "X", "Y",     # coordinates
            "Extraction_depth", "Watercolumn", "GW_Table")) %>% 
  na.omit() %>% 
  scale(center = T, scale = T) %>% 
  as.data.frame()
cor_matrix <- cor(df_alpha)
highly_correlated <- caret::findCorrelation(cor_matrix, cutoff = 0.9) 
# none
# df_alpha <- df_alpha[, - highly_correlated] 


# lets see if any env vars can be packed neatly in PCs
pca_env <- prcomp(df_alpha, scale = FALSE)
biplot(pca_env)

```

```{r pca-plot}

ggplot2::autoplot(pca_env, 
         
           data = 
           (
           df_alpha %>% 
           rownames_to_column("sample_season") %>% 
           left_join(., metadata[,c("category", "sample_season")], 
                     by = "sample_season") 
           ), 
           
         colour = 'category',
         size=5, 
         alpha = 0.2,
         loadings = TRUE, 
         loadings.colour = "black", 
         loadings.label = TRUE, 
         loadings.label.size = 4.3, 
         loadings.label.colour = "black",
         loadings.label.repel = TRUE) +
  
  geom_vline(xintercept = c(0), color = "grey70", linetype = 2) +
  geom_hline(yintercept = c(0), color = "grey70", linetype = 2) +
  scale_color_manual(values = pal3)+
  theme(legend.background = element_blank(),
        legend.box.background = element_rect(colour = "gray"))  -> pca_plot


pca_plot
```
The first three principal components explain 57% of the environmental variance in data. We can see that neither this simplification yields as clear results as sometimes obtained. It is not surprising that the communties nmds gives unclear patterns, as well. 

```{r pca-importance}
summary(pca_env)$importance %>% 
  as.data.frame() %>% 
  dplyr::select("PC1", "PC2", "PC3", "PC4")
```

Let us see which variables vary together (group together in which component):
```{r pca-loadings}
# Extract the loadings from the PCA result and convert to tidy format 
loadings_df <-   tidy(pca_env, matrix = "rotation")


# PC1
# Create the ggplot2 object for plotting the loadings
loadings_df %>% filter(PC == "1") %>% 
  #x=reorder(class,-amount,sum)
ggplot( aes(x = reorder(column, -value), y = value, group = factor(column))) +
  geom_bar(stat = "identity", position = "dodge", 
           fill= "gray90", color = "gray20") +
  geom_text(aes(label = column), position = position_dodge(width = 0.9), 
            #vjust = "inward",  
            angle = 90 , hjust = "inward") +
  labs(x = "Variables of PC1", y = "Loadings") +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
        legend.position = "none")  -> plot_pca1

# PC2 
loadings_df %>% filter(PC == "2") %>% 
  #x=reorder(class,-amount,sum)
ggplot( aes(x = reorder(column, -value), y = value, group = factor(column))) +
  geom_bar(stat = "identity", position = "dodge", 
           fill= "gray90", color = "gray20") +
  geom_text(aes(label = column), position = position_dodge(width = 0.9), 
            #vjust = "inward",  
            angle = 90 , hjust = "inward") +
  labs(x = "Variables of PC2", y = "Loadings") +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
        legend.position = "none") -> plot_pca2

# PC3
loadings_df %>% filter(PC == "3") %>% 
  #x=reorder(class,-amount,sum)
ggplot( aes(x = reorder(column, -value), y = value, group = factor(column))) +
  geom_bar(stat = "identity", position = "dodge", 
           fill= "gray90", color = "gray20") +
  geom_text(aes(label = column), position = position_dodge(width = 0.9), 
            #vjust = "inward",  
            angle = 90 , hjust = "inward") +
  labs(x = "Variables of PC3", y = "Loadings") +
  theme_minimal() +
  theme(axis.text.x = element_blank(),
        legend.position = "none") -> plot_pca3

plot_pca1 + plot_pca2 + plot_pca3
```


```{r nmds-pca-plot}
nmds_plot2 <-  as.data.frame(nmds$points) %>% 
  cbind(., as.factor(metadata$category)) %>% 
  dplyr::rename("cat" = "as.factor(metadata$category)") %>%
  filter(cat !=  "NA") %>% 
  ggplot(aes(x=MDS1,y=MDS2) ) +
  geom_point(aes( color = cat),
             size = 5, alpha = 0.2) +  
  scale_color_manual(values=pal3) +
  stat_ellipse(aes(colour = cat), linewidth = 0.4) + 
  theme(legend.position = "none") +
  geom_vline(xintercept = c(0), color = "grey70", linetype = 2) +
  geom_hline(yintercept = c(0), color = "grey70", linetype = 2) 

pca_plot2 <- pca_plot + theme(legend.position = "none") + 
  stat_ellipse(aes(colour = category), linewidth = 0.4) 
nmds_plot2 + pca_plot2
```

Conclusion: there is no distinct clustering by temperature in terms of microbial communities, but there is two different clusters in terms of environmental conditions: >10 C samples and 18+ samples are separated along the first PCA axis, which was mostly influenced by pH, and various ions/conductivity. The pH variation is much more pronounced in the cold samples, than warm ones.

While reference samples show low variation in environmental variables and high difference in communities, the opposite is true for extremely cold samples, which are mostly uniform in all variables except for pH and are quite simmilar community-wise.

It is possible that the stress of pH varibility (since pH is known to be a determining factor in composition) selects for resilient organisms, while on the other hand the reference samples allow a more even environment.



### Constrained ordination

CAP ordination as an distance-based alternative to the RDA (which uses bray, as opposed to RDA’s euclidean). Hellinger transformation (square root of relative abundances) is used to account for compositionality of data.


```{r constraints}
# env clean
# df_alpha - already scaled and selected the important variables

# aggregate to genus
# asv_aggregated - already done for nmds
 
# asv clean
# because some samples get removed because of NAs 
asv_aggregated [, which  ( colnames(asv_aggregated) %in% rownames(df_alpha)) ] -> sp.dat

# transform hellinger (or clr sometimes)
decostand(sp.dat, method = "hellinger") -> sp.dat
#clr(sp.dat) -> sp.dat

# 1. first model
simpleRDA <- capscale(t(sp.dat) ~  ., data = df_alpha ,
                 distance = "bray",
                 scaling = "sites")
# take only that are vif<10
env_vars_low_vif <- vif.cca(simpleRDA) %>% 
                    as.data.frame() %>% 
                    dplyr::rename("env" = ".") %>% 
                    dplyr::filter(env < 10) 

df_alpha[,which(colnames(df_alpha) %in%  rownames(env_vars_low_vif) )] -> env.dat


# 2. model without them
simpleRDA <- capscale(t(sp.dat) ~  ., 
                      data=  env.dat ,
                 distance = "bray",
                 scaling = "sites")


# test all variables and axes
# canonical axes
anova.model <- anova.cca(simpleRDA, by='axis', step=1000)  
# no axes sign

# the whole model
anova.model2 <- anova.cca(simpleRDA, step=1000) #is sign
RsquareAdj(simpleRDA)$adj.r.squared # and explains <1%


# env parameters
anova.model3 <- anova(simpleRDA, step=1000, by = "term") 
# none sign



```

None of the environmental variables are significant for the composition.

```{r, eval=FALSE, include=FALSE}

# 3. final model
simpleRDA <- capscale(t(sp.dat) ~  Temp +  DOC + K + O2, data=env.dat ,
                 distance = "bray",
                 scaling = "sites")

#summary(simpleRDA) 
# now 1.4%

```

```{r, eval=FALSE, include=FALSE}
# vectors
ccavectors <- as.matrix(scores(simpleRDA, display = "bp", scaling = "sites")*40) %>% 
  t() %>% as.data.frame() %>% 
  rename("K**" = "K",
         "Temp." = "Temp",
         "O2*" = "O2") %>%
  t() %>% as.data.frame()

# site coordinates
site_data <- scores(simpleRDA, display = "sites") %>% 
  as.data.frame() %>% 
  cbind(., new_metadata$category) %>% 
  rename("cat" = "new_metadata$category")

# plotting
plot_cca <- 
  site_data %>% 
  ggplot( aes(x = CAP1, y = CAP2)) +
  geom_point(aes( color= cat), alpha = 0.2, size = 3) +
  geom_point(aes( color= cat), shape = 21, size = 3) +  
  geom_segment(data = ccavectors, aes(x = 0, y = 0, xend = CAP1, yend = CAP2), size = 1.2,
               arrow = arrow(length = unit(0.5, "cm"))) +
   geom_vline(xintercept = c(0), color = "grey70", linetype = 2) +
   geom_hline(yintercept = c(0), color = "grey70", linetype = 2) +
  geom_text(data = ccavectors, aes(x = CAP1*1.5, y = CAP2*1.5, 
                                   label = rownames(ccavectors)),
                                   #nudge_x = 0.3, nudge_y = 0.3
                                   size=6 ) +
  theme_bw() +
  scale_fill_manual(values= pal3) +
  scale_color_manual(values=pal3) +
  labs(x = "CAP1 [1.6%]", y="CAP2 [0.7%]") +
  stat_ellipse(aes(color=cat), size = 1, alpha = 0.5) + 
  #stat_ellipse(aes(fill = cat), geom="polygon", level=0.95, alpha=0.09) +
  labs( color = "Temperature \ncategory", fill = "Temperature category", 
        title = "Bray distances of hellinger transformed samples (n = 191), 180 classes.") +
  
     theme(legend.background = element_blank(),
           legend.box.background = element_rect(colour = "gray")) 

plot_cca


```

# Donauschotter subset

## Data preparation
```{r ds-prep}

spring_data_additional <- read.csv("C:/Users/Angela Cukusic/Desktop/DS_analysis/data/spring_data_additional.csv", 
         check.names = FALSE, row.names = 1)

spring_data_additional$sample_season <- paste(spring_data_additional$Sample_ID, 
                                              "spring", sep = "_")

spring_data_additional %>% column_to_rownames("sample_season") %>% 
  mutate(OF_beb = as.factor(OF_beb),
         hts_GWWP = as.factor(hts_GWWP),
         hts_EWS = as.factor(hts_EWS),
         hts_No_UHI = as.factor(hts_No_UHI),
         hts_UB = as.factor(hts_UB),
         hts_kanal = as.factor(hts_kanal),
         hts_FW = as.factor(hts_FW),
         hts_Altlast = as.factor(hts_Altlast),
         hts_OGFliess = as.factor(hts_OGFliess),
         hts_OGSteh = as.factor(hts_OGSteh),
         hts_Versie = as.factor(hts_Versie),
         hts_UHI = as.factor(hts_UHI),
         hts_count = as.factor(hts_count)) -> spring_data_additional


# add ens
merge(as.data.frame(ens), spring_data_additional, by = "row.names")  -> spring_data_additional

# filter only DS subset
spring_data_additional %>% 
  dplyr::filter(grepl('DS', Geol_beb)) %>% 
  column_to_rownames("Row.names") -> spring_data_additional
```

## Ens in relation to env vars
```{r ds-uhi}
# of_beb
split_labels <- str_wrap(c("no effect", "running water effect", 
                           "unclear"), width = 8)

p1 <- spring_data_additional %>% 
  #dplyr::filter(OF_beb != "NA") %>% 
  ggplot(aes(x=OF_beb, y=ens)) + 
  geom_jitter(width = 0.2, size = 3, shape=21, fill = "violet") +
  geom_boxplot(fill = "violet", alpha=0.5, outlier.shape = NA) +
  labs(x="Surface water impact", 
       y= "Shannons diversity index") +
  scale_x_discrete(labels = split_labels)



# surface seasling

p2 <- spring_data_additional %>% 
  dplyr::filter(hts_Versie != "NA") %>% 
  ggplot(aes(x=hts_Versie, y=ens)) + 
  geom_jitter(width = 0.2, size = 3, shape=21, fill = "violet") +
  geom_boxplot(fill = "violet", alpha=0.5, outlier.shape = NA) + 
  labs(x="Surface sealing", 
       y= NULL) +
 scale_x_discrete(labels = c(">25%", "+25%"))


#redox and wastewater info missing 
#split_labels <- str_wrap(c("o2 > 2", "o2 < 2", 
                           #"Mn>0.15 & Fe>0.15", 
                           #"s>0.1"), width = 8)


p3 <- spring_data_additional %>% 
  dplyr::filter(hts_UHI != "NA") %>% 
  ggplot(aes(x=hts_UHI, y = ens)) + 
  geom_jitter(width = 0.2, size = 3, shape=21, fill = "violet") +
  geom_boxplot(fill = "violet", alpha=0.5, outlier.shape = NA) + 
  labs(x="UHI count", 
       y= NULL) 

p1 + p2 + p3 
```



## Ordination
```{r}
# add metals
```

